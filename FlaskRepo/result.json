{"success":true,"data":[{"id":"58eee565a92d341e48cfe7fc","author_id":"54009f5ccd66f2eb37190485","tab":"share","content":"<div class=\"markdown-text\"><h1>2017，我们来聊聊 Node.js</h1>\n<h2>版本帝？</h2>\n<p>Chrome浏览器已经蹦到57版本了，是名副其实的版本帝，作为兄弟的Node.js也一样，1.0之前等了6年，而从1.0到8.0，只用了2年时间，这世界到底怎么了？</p>\n<p>我们就数一下</p>\n<ul>\n<li>从v0.1到0.12用了6年</li>\n<li>2015-01-14发布了v1.0.0版本（io.js）</li>\n<li>2.x（io.js）</li>\n<li>3.x（io.js）</li>\n<li>2015年09月Node.js基金会已发布Node.js V4.0版 与io.js合并后的第一个版本</li>\n<li>2015年10月Node.jsv4.2.0将是首个lts长期支持版本</li>\n<li>2016年底发布到4.2.4 &amp;&amp; 5.4.0</li>\n<li>2016年3月20日v4.4.0 LTS（长期支持版本）和v5.9.0 Stable（稳定版本）</li>\n<li>2016 年底 v6.0 支持95%以上的es6特性 ， v7.0通过flag支持async函数，99%的es6特性</li>\n<li>2017年2月发布v7.6版本，可以不通过flag使用async函数</li>\n</ul>\n<p><img src=\"//dn-cnode.qbox.me/Fv8fvViUeOJpBlOWYzBo1txRUhdN\" alt=\"lts-schedule.png\"></p>\n<p>整体来说趋于稳定</p>\n<ul>\n<li>成立了Node.js基金会，能够让Node.js在未来有更好的开源社区支持</li>\n<li>发布了LTS版本，意味着api稳定</li>\n<li>快速发版本，很多人吐槽这个，其实换个角度看，这也是社区活跃的一个体现，但如果大家真的看CHANGELOG，其实都是小改进，而且是边边角角的改进，也就是说Node.js的core（核心）已经非常稳定了，可以大规模使用</li>\n</ul>\n<h2>已无性能优势？</h2>\n<p>Node.js在2009年横空出世，可以说是纯异步获得高性能的功劳。所有语言几乎没有能够和它相比的，比如Java、PHP、Ruby都被啪啪的打脸。但是山一程，水一程，福祸相依，因为性能太出众，导致很多语言、编程模型上有更多探索，比如go语言产生、php里的swolo和vm改进等，大家似乎都以不支持异步为耻辱。后来的故事大家都知道了，性能都提到非常高，c10问题已经没人再考虑，只是大家实现早晚而产生的性能差距而已。</p>\n<blockquote>\n<p>编程语言的性能趋于一样的极限，所以剩下的选择，只有喜好</p>\n</blockquote>\n<p>那么在这种情况下，Node.js还有优势么？</p>\n<ul>\n<li>实现成本：Node.js除了异步流程控制稍复杂外，其他的都非常简单，比如写法，你可以面向过程、面向对象、函数式，根据自己的解决选择就好了。不要因为它现在变化快，就觉得自己跟不上潮流。尤其是后端程序员转Node.js几乎是2周以内的成本，某些语言光熟悉语法习惯也不止2周吧？</li>\n<li>调优成本：Node.js即使不优化，它的性能也非常好，如果优化，也比其他语言更简单</li>\n<li>学习成本：是否必须用，如果是必须要用，那就少学一样是一样，人生有限，不能都花在写hello world上。我想问，大前端离得开js么？</li>\n</ul>\n<blockquote>\n<p>误读：Node.js已无性能优势，它现在最强大的是基于npm的生态</p>\n</blockquote>\n<p>上面是成本上的比较，其实大家把关注点都转移到基于npm的生态上，截止2017年2月，在npm上有超过45万个模块，秒杀无数。npm是所有的开源的包管理里最强大的，我们说更了不起的Node.js，其实npm居功甚伟，后面会有独立的章节进行阐述。</p>\n<p>来自<a href=\"http://www.modulecounts.com/\">www.modulecounts.com</a>的各个包管理模块梳理的比较</p>\n<p><img src=\"//dn-cnode.qbox.me/FjmazMxffKETUdl9-NVoSqLB-DyT\" alt=\"Screen Shot 2017-04-04 at 21.02.41.png\">\nnpm生态是Node的优势不假，可是说“Node.js没有性能优势”真的对么？这其实就是误读，Node.js的性能依然很好呀，而且它有npm极其强大的生态，可谓性能与生态双剑合璧，你说你死不死？</p>\n<h2>异步和回调地狱？</h2>\n<blockquote>\n<p>天生异步，败也异步，成也异步</p>\n</blockquote>\n<p>正因为异步导致了api设计方式只能采用error-first风格的回调，于是大家硬生生的把callback写成了callback hell。于是各种黑粉就冒出来，无非是一些浅尝辄止之辈。但也正因为回调地狱是最差实践，所以大家才不得不求变，于是thunk、promise等纷沓而至。虽然Promise/A+不完美，但对于解决回调地狱是足够的了。而且随着ES6等规范实现，引入generator、co等，让异步越来越近于同步。当async函数落地的时候，Node已经站在了同C#、Python一样的高度上，大家还有什么理由黑呢？</p>\n<p>本小节先科普一下异步流程里的各种概念，后面会有独立章节进行详细讲解</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>说明</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>callback</td>\n<td>Node.js API天生就是这样的</td>\n<td></td>\n</tr>\n<tr>\n<td>thunk</td>\n<td>参数的求值策略</td>\n<td></td>\n</tr>\n<tr>\n<td>promise</td>\n<td>最开始是Promise/A+规范，随后成为ES6标准</td>\n<td></td>\n</tr>\n<tr>\n<td>generator</td>\n<td>ES6种的生成器，用于计算，但tj想用做流程控制</td>\n<td></td>\n</tr>\n<tr>\n<td>co</td>\n<td>generator用起来非常麻烦，故而tj写了co这个generator生成器，用法更简单</td>\n<td></td>\n</tr>\n<tr>\n<td>async函数</td>\n<td>原本计划进入es7规范，结果差一点，但好在v8实现了，所以node 7就可以使用，无须等es7规范落地</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>有时，将一件事儿做到极致，也许能有另一种天地</p>\n</blockquote>\n<h2>应用场景</h2>\n<p>MEAN是一个Javascript平台的现代Web开发框架总称，它是MongoDB + Express +AngularJS + NodeJS 四个框架的第一个字母组合。它与传统LAMP一样是一种全套开发工具的简称。在2014和2015年喜欢讲这个，并且还有MEAN.js等框架，但今天已经过时，Node.js有了更多的应用场景。</p>\n<p>《Node.js in action》一书里说，Node所针对的应用程序有一个专门的简称：DIRT。它表示数据密集型实时（data-intensive real-time）程序。因为Node自身在I/O上非常轻量，它善于将数据从一个管道混排或代理到另一个管道上，这能在处理大量请求时持有很多开放的连接，并且只占用一小部分内存。它的设计目标是保证响应能力，跟浏览器一样。</p>\n<p>这话不假，但在今天来看，DIRT还是范围小了。其实DIRT本质上说的I/O处理的都算，但随着大前端的发展，Node.js已经不再只是I/O处理相关，而是更加的“Node”！</p>\n<p>这里给出Node.js的若干使用场景</p>\n<ul>\n<li>网站（如express/koa等）</li>\n<li>im即时聊天(<a href=\"http://socket.io\">socket.io</a>)</li>\n<li>api（移动端，pc，h5）</li>\n<li>HTTP Proxy（淘宝、Qunar、腾讯、百度都有）</li>\n<li>前端构建工具(grunt/gulp/bower/webpack/fis3…)</li>\n<li>写操作系统（NodeOS）</li>\n<li>跨平台打包工具（PC端的electron、nw.js，比如钉钉PC客户端、微信小程序IDE、微信客户端，移动的cordova，即老的Phonegap，还有更加有名的一站式开发框架ionicframework）</li>\n<li>命令行工具（比如cordova、shell.js）</li>\n<li>反向代理（比如anyproxy，node-http-proxy）</li>\n<li>编辑器Atom、VSCode等</li>\n</ul>\n<p>可以说目前大家能够看到的、用到的软件都有Node.js身影，当下最流行的软件写法也大都是基于Node.js的，比如PC客户端<a href=\"https://github.com/luin/medis\">luin/medis</a>采用electron打包，写法采用React+Redux。我自己一直的实践的【Node全栈】，也正是基于这种趋势而形成的。在未来，Node.js的应用场景会更加的广泛。更多参见<a href=\"https://github.com/sindresorhus/awesome-nodejs\">sindresorhus/awesome-nodejs</a>。</p>\n<h3>Web框架</h3>\n<p>演进时间线大致如下：</p>\n<ul>\n<li>2010年tj写的Express</li>\n<li>2011年Derby.js开始开发，8月5日，WalmartLabs的一位成员Eran Hammer提交了Hapi的第一次commit。Hapi原本是Postmile的一部分，并且最开始是基于Express构建的。后来它发展成自己自己的框架，</li>\n<li>2012年1月21日，专注于rest api的restify发布1.0版本，同构的meteor开始投入开发，最像rails的sails也开始了开发</li>\n<li>2013年tj开始玩generator，编写co这个generator执行器，并开始了Koa。2013 年下半年李成银开始ThinkJS，参考ThinkPHP</li>\n<li>2014年，4月9日，express发布4.0，进入4.x时代持续到今天，MEAN.js开始随着MEAN架构的提出开始开发，意图大一统，另外total.js开始，最像PHP’s Laravel 或 Python’s Django 或 <a href=\"http://ASP.NET\">ASP.NET</a> MVC的框架</li>\n<li>2015年8月22日， 下一代Web框架Koa发布1.0，可以在node 0.12下面，通过co + generator实现同步逻辑，那时候co还是基于thunkfy的，2015.10.30 ThinkJS发布了Es2015+ 特性开发的v 2.0版本</li>\n<li>2016 年 09 月，蚂蚁金服的eggjs，在 JSConf China 2016 上亮相并宣布开源</li>\n<li>2017年2月，下一代Web框架Koa发布2.0</li>\n</ul>\n<p>我们可以根据框架的特性进行分类</p>\n<table>\n<thead>\n<tr>\n<th>框架名称</th>\n<th>特性</th>\n<th>点评</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Express</td>\n<td>简单、实用，路由中间件等五脏俱全</td>\n<td>最著名的Web框架</td>\n</tr>\n<tr>\n<td>Derby.js &amp;&amp; Meteor</td>\n<td>同构</td>\n<td>前后端都放到一起，模糊了开发便捷，看上去更简单，实际上上对开发来说要求更高</td>\n</tr>\n<tr>\n<td>Sails、Total</td>\n<td>面向其他语言，Ruby、PHP等</td>\n<td>借鉴业界优秀实现，也是Node.js成熟的一个标志</td>\n</tr>\n<tr>\n<td>MEAN.js</td>\n<td>面向架构</td>\n<td>类似于脚手架，又期望同构，结果只是蹭了热点</td>\n</tr>\n<tr>\n<td>Hapi和Restfy</td>\n<td>面向Api &amp;&amp; 微服务</td>\n<td>移动互联网时代Api的作用被放大，故而独立分类。尤其是对于微服务开发更是利器</td>\n</tr>\n<tr>\n<td>ThinkJS</td>\n<td>面向新特性</td>\n<td>借鉴ThinkPHP，并慢慢走出自己的一条路，对于Async函数等新特性支持，无出其右</td>\n</tr>\n<tr>\n<td>Koa</td>\n<td>专注于异步流程改进</td>\n<td>下一代Web框架</td>\n</tr>\n</tbody>\n</table>\n<p>对于框架选型</p>\n<ul>\n<li>业务场景、特点，不必为了什么而什么，避免本末倒置</li>\n<li>自身团队能力、喜好，有时候技术选型决定团队氛围的，需要平衡激进与稳定</li>\n<li>出现问题的时候，有人能Cover的住，Node.js虽然8年历史，但模块完善程度良莠不齐，如果不慎踩到一个坑里，需要团队在无外力的情况能够搞定，否则会影响进度</li>\n</ul>\n<blockquote>\n<p>个人学习求新，企业架构求稳，无非喜好与场景而已</p>\n</blockquote>\n<p>我猜大家能够想到的场景，大约如下</p>\n<ul>\n<li>前端工具，比如gulp、grunt、webpack等</li>\n<li>服务器，做类似于Java、PHP的事儿</li>\n</ul>\n<p>如果只是做这些，和Java、PHP等就没啥区别了。如果再冠上更了不起的Node.js，就有点名不符实了。所以这里我稍加整理，看看和大家想的是否一样</p>\n<h3>技术栈演进</h3>\n<p>自从ES 2015（俗称ES 6）在Node.js 落地之后，整个Node.js开发都发生了翻天覆地的变化。自从0.10开始，Node.js就逐渐的加入了ES 6特性，比如0.12就可以使用generator，才导致寻求异步流程控制的tj写出了co这个著名的模块，继而诞生了Koa框架。但是在4.0之前，一直都是要通过flag才能开启generator支持，故而Koa 1.0迟迟未发布，在Node 4.0发布才发布的Koa 1.0。</p>\n<blockquote>\n<p>2015年，成熟的传统，而2016年，变革开始</p>\n</blockquote>\n<p>核心变更：es语法支持</p>\n<ul>\n<li>使用Node.js 4.x或5.x里的es6特性，如果想玩更高级的，可以使用<a href>babel</a>编译支持es7特性，或者typescript</li>\n<li>合理使用<a href=\"https://github.com/feross/standard\">standard</a>  或者 xo 代码风格约定</li>\n<li>适当的引入ES 6语法，只要Node.js SDK支持的，都可以使用</li>\n<li>需要大家重视OO（面向对象）写法的学习和使用，虽然ES 6的OO机制不健全，但这是大方向，以后会一直增强。OO对于大型软件开发更好。这其实也是我看好typescript的原因。</li>\n</ul>\n<p>对比一下变革前后的技术栈选型，希望读者能够从中感受到其中的变化</p>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>2015年</th>\n<th>2016年</th>\n<th>选型原因</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Web框架</td>\n<td>express 4.x</td>\n<td>koa 1.0 &amp;&amp; 2.0 （koa2.0刚发布不久，喜欢折腾的可以考虑）</td>\n<td>主要在流程控制上的便利，异步毕竟要时刻注意，心累</td>\n</tr>\n<tr>\n<td>数据库</td>\n<td>mongoose（mongodb）</td>\n<td>mongoose（mongodb）</td>\n<td>对mongodb和mysql支持都一样，不过是mongodb更简单，足以应付绝大部分场景</td>\n</tr>\n<tr>\n<td>异步流程控制</td>\n<td>bluebird（Promise/A+实现）</td>\n<td>bluebird（Promise/A+实现）1） Koa 1.0 使用co + generator 2） Koa 2.0 使用async函数</td>\n<td>流程控制演进路线，从promise到async函数，无论如何，promise都是基石，必要掌握的</td>\n</tr>\n<tr>\n<td>模板引擎（视图层）</td>\n<td>ejs &amp;&amp; jade</td>\n<td>jade &amp;&amp; nunjucks</td>\n<td>给出了2种，一种可读性好，另一种简洁高效，都是非常好的</td>\n</tr>\n<tr>\n<td>测试</td>\n<td>mocha</td>\n<td>ava</td>\n<td>mocha是Node.js里著名的测试框架，但对新特性的支持没有ava那么好，而ava基于babel安装也要大上好多</td>\n</tr>\n<tr>\n<td>调试</td>\n<td>node-inspector</td>\n<td>VSCode</td>\n<td>在Node 6和7出来之后，node-inspector支持的不是那么好，相反VSCode可视化，简单，文件多时也不卡，特别好用</td>\n</tr>\n</tbody>\n</table>\n<h3>预处理器</h3>\n<p>前端预处理可分3种</p>\n<ul>\n<li>模板引擎</li>\n<li>css预处理器</li>\n<li>js友好语言</li>\n</ul>\n<p>这些都离不开Node.js的支持，对于前端工程师来说，使用Node.js来实现这些是最方便不过的。</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>实现</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>模板引擎</td>\n<td>art\\mustache\\ejs\\hbs\\jade …</td>\n<td>上百种之多，自定义默认，编译成html，继而完成更多操作</td>\n</tr>\n<tr>\n<td>css预处理器</td>\n<td>less\\sass\\scss\\rework\\postcss</td>\n<td>自定义语法规则，编译成css</td>\n</tr>\n<tr>\n<td>js友好语言</td>\n<td>coffeescript、typescript</td>\n<td>自定义语法规则、编译成js</td>\n</tr>\n</tbody>\n</table>\n<h3>跨平台</h3>\n<p>跨平台指的是PC端、移动端、Web/H5</p>\n<table>\n<thead>\n<tr>\n<th>平台</th>\n<th>实现</th>\n<th>点评</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Web/H5</td>\n<td>纯前端</td>\n<td>不必解释</td>\n</tr>\n<tr>\n<td>PC客户端</td>\n<td>nw.js和electron</td>\n<td>尤其是atom和vscode编辑器最为著名，像钉钉PC端，微信客户端、微信小程序IDE等都是这样的，通过web技术来打包成PC客户端</td>\n</tr>\n<tr>\n<td>移动端</td>\n<td>cordova（旧称PhoneGap），基于cordova的ionicframework</td>\n<td>这种采用h5开发，打包成ipa或apk的应用，称为Hybrid开发（混搭），通过webview实现所谓的跨平台，应用的还是非常广泛的</td>\n</tr>\n</tbody>\n</table>\n<h3>构建工具</h3>\n<p>说起构建工具，大概会想到make、ant、rake、gradle等，其实Node.js里有更多实现</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>介绍</th>\n<th>点评</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>jake</td>\n<td>基于coffeescript的大概都熟悉这个，和make、rake类似</td>\n<td>经典传统</td>\n</tr>\n<tr>\n<td>grunt</td>\n<td>dsl风格的早期著名框架</td>\n<td>配置非常麻烦</td>\n</tr>\n<tr>\n<td>gulp</td>\n<td>流式构建，不会产生中间文件，利用Stream机制，处理大文件和内存有优势，配置简单，只有懂点js就能搞定</td>\n<td>grunt的替代品</td>\n</tr>\n<tr>\n<td>webpack + npm scripts</td>\n<td>说是构建工具有点过，但二者组合勉强算吧，loader和plugin机制还是非常强大的</td>\n<td>流行而已</td>\n</tr>\n</tbody>\n</table>\n<p>构建工具都不会特别复杂，所以Node.js世界里有非常多的实现，还有人写过node版本的make呢，玩的很嗨</p>\n<h3>HTTP Proxy</h3>\n<ul>\n<li>请求代理</li>\n<li>SSR &amp;&amp; PWA</li>\n<li>Api Proxy</li>\n</ul>\n<p>1）请求代理</p>\n<p>对于http请求复杂定制的时候，你是需要让Node.js来帮你的，比如为了兼容一个历史遗留需求，在访问某个CSS的时候必须提供HEADER才可以，如果放到静态server或cdn上是做不到的。</p>\n<p>2）SSR &amp;&amp; PWA</p>\n<p>SSR是服务器端渲染，PWA是渐进式Web应用，都是今年最火的技术。如果大家用过，一定对Node.js不陌生。比如React、Vuejs都是Node.js实现的ssr。至于pwa的service-worker也是Node.js实现的。那么为啥不用其他语言实现呢？不是其他语言不能实现，而是使用Node.js简单、方便、学习成本低，轻松获得高性能，如果用其他语言，我至少还得装环境</p>\n<p>3）Api Proxy</p>\n<p>产品需要应变，后端不好变，一变就要设计到数据库、存储等，可能引发事故。而在前端相对更容易，前端只负责组装服务，而非真正对数据库进行变动，所以只要服务api粒度合适，在前端来处理是更好的。</p>\n<p>Api的问题</p>\n<ul>\n<li>一个页面的Api非常多</li>\n<li>跨域，Api转发</li>\n<li>Api返回的数据对前端不友好，后端讨厌（应付）前端，几种api都懒得根据ui/ue去定制，能偷懒就偷懒</li>\n<li>需求决定Api，Api不一定给的及时</li>\n</ul>\n<p>所以，在前端渲染之余，加一层Api Proxy是非常必要的。淘宝早起曾公开过一张架构图，在今天看来，依然不过时</p>\n<p><img src=\"//dn-cnode.qbox.me/Fr8cGvus0i58atULAnoe-Cv4nu5m\" alt=\"taobao.jpg\"></p>\n<ul>\n<li>左侧半边，浏览器和Node.js Server通信可以有多种协议，HTML、RESTfull、BigPipe、Comet、Socket等，已经足够我们完成任何想做的事儿了</li>\n<li>右侧半边，是Node.js实现的WebServer，Node服务分了2个部分\n<ul>\n<li>常规的Http服务，即大块部分二</li>\n<li>ModelProxy指的是根据Server端的服务，组成并转化成自身的Model层。磨蹭用于为Http服务提供更好的接口</li>\n</ul>\n</li>\n</ul>\n<p>这里的Model Proxy其实就是我们所说的Api Proxy，这张图里只是说了结果，把聚合的服务转成模型，继而为HTTP服务提供Api。</p>\n<p>下面我们再深化一下Api Proxy的概念</p>\n<p><img src=\"//dn-cnode.qbox.me/FpAZo4aPQysJyciBvzUCU9uxb-vf\" alt=\"proxy.png\"></p>\n<p>这里的Node Proxy做了2件事儿，Api和渲染辅助。</p>\n<ul>\n<li>前端的异步ajax请求，可以直接访问Api</li>\n<li>如果是直接渲染或者bigpipe等协议的，需要在服务器端组装api，然后再返回给浏览器。</li>\n</ul>\n<p>所以Api后面还有一个服务组装，在微服务架构流行的今天，这种服务组装放到Node Proxy里的好处尤其明显。既可以提高前端开发效率，又可以让后端更加专注于服务开发。甚至如果前端团队足够大，可以在前端建一个Api小组，专门做服务集成的事儿。</p>\n<h3>Api服务</h3>\n<p>说完了Proxy，我们再看看利益问题。Node.js向后端延伸，必然会触动后端开发的利益。那么Proxy层的事儿，前后端矛盾的交界处，后端不想变，前端又求变，那么长此以往，Api接口会变得越来越恶心。后端是愿意把Api的事儿叫前端的，对后端来说，只要你不动我的数据库和服务就可以。</p>\n<p>但是Node.js能不能做这部分呢？答案是能的 ，这个是和Java、PHP类似的，一般是和数据库连接到一起，处理带有业务逻辑的。目前国内大部分都是以Java、PHP等为主，所以要想吃到这部分并不容易。</p>\n<ul>\n<li>小公司，创业公司，新孵化的项目更倾向于Node.js，简单，快速，高效</li>\n<li>微服务架构下的某些服务，使用Node.js开发，是比较合理的</li>\n</ul>\n<p>国内这部分一直没有做的很好，所以Node.js在大公司还没有很好的被应用，安全问题、生态问题、历史遗留问题等，还有很多人对Node.js的误解</p>\n<ul>\n<li>单线程很脆弱，这是事实，但单线程不等于不能多核并发，而且你还有集群呢</li>\n<li>运维，其实很简单，比其他语言之简单，日志采集、监控也非常简单</li>\n<li>模块稳定性，对于Mongodb、MySQL、Redis等还是相当不错，但其他的数据库支持可能没那么好。</li>\n<li>安全问题，</li>\n</ul>\n<p>这些对于提供Api服务来说已经足够了。</p>\n<h3>其他</h3>\n<table>\n<thead>\n<tr>\n<th>用途</th>\n<th>说明</th>\n<th>前景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>爬虫</td>\n<td>抢了不少Python的份额，整体来说简单，实用</td>\n<td>看涨</td>\n</tr>\n<tr>\n<td>命令行工具</td>\n<td>写工具、提高效率，node+npm真是无出其右</td>\n<td>看涨</td>\n</tr>\n<tr>\n<td>微服务与RPC</td>\n<td>Node做纯后端不好做，但在新项目和微服务架构下，必有一席之地</td>\n<td>看涨</td>\n</tr>\n<tr>\n<td>微信公众号开发</td>\n<td>已经火了2年多了，尤其是付费阅读领域，还会继续火下去，gitchat就是使用Node.js做的，而且还在招人</td>\n<td>看涨</td>\n</tr>\n<tr>\n<td>反向代理</td>\n<td>Node.js可以作为nginx这样的反向代理，虽然线上我们很少这样做，但它确确实实可以这样做。比如node-http-proxy和anyproxy等，其实使用Node.js做这种请求转发是非常简单的</td>\n<td>看涨</td>\n</tr>\n</tbody>\n</table>\n<h2>更好的写法</h2>\n<h3>Async函数与Promise</h3>\n<ul>\n<li>Async函数是趋势，Chrome 52. v8 5.1已经支持Async函数(<a href=\"https://github.com/nodejs/CTC/issues/7\">https://github.com/nodejs/CTC/issues/7</a>)了，Node.js 7.0+支持还会远么？</li>\n<li>Async和Generator函数里都支持promise，所以promise是必须会的。</li>\n<li>Generator和yield异常强大，不过不会成为主流，所以学会基本用法和promise就好了，没必要所有的都必须会。</li>\n<li>co作为Generator执行器是不错的，它更好的是当做Promise 包装器，通过Generator支持yieldable，最后返回Promise，是不是有点无耻？</li>\n</ul>\n<p>我整理了一张图，更直观一些。</p>\n<p><img src=\"//dn-cnode.qbox.me/FkcPwxdGHSCHFvA2nU0ub0zYNRt4\" alt=\"async-all.png\"></p>\n<ul>\n<li>红色代表Promise，是使用最多的，无论async还是generator都可用</li>\n<li>蓝色是Generator，过度货</li>\n<li>绿色是Async函数，趋势</li>\n</ul>\n<p><strong>结论</strong>：Promise是必须会的，那你为什么不顺势而为呢？</p>\n<p><strong>推荐</strong>：使用Async函数 + Promise组合，如下图所示。</p>\n<p><img src=\"//dn-cnode.qbox.me/FhVQF1FKB6sNkoFTc3gU-SVnkGtm\" alt=\"async-suggest.png\"></p>\n<p><strong>实践</strong></p>\n<p>合理的结合Promise和Async函数是可以非常高效的，但也要因场景而异</p>\n<ul>\n<li>Promise更容易做promisefyAll（比如使用bluebird）</li>\n<li>Async函数无法批量操作</li>\n</ul>\n<p>那么，在常见的Web应用里，我们总结的实践是，dao层使用Promise比较好，而service层，使用Async/Await更好。</p>\n<p>dao层使用Promise：</p>\n<ul>\n<li>crud</li>\n<li>单一模型的方法多</li>\n<li>库自身支持Promise</li>\n</ul>\n<p>这种用promisefyAll基本几行代码就够了，一般单一模型的操作，不会特别复杂，应变的需求基本不大。</p>\n<p>而service层一般是多个Model组合操作，多模型操作就可以拆分成多个小的操作，然后使用Await来组合，看起来会更加清晰，另外对需求应变也是非常容易的。</p>\n<h3>ES.next</h3>\n<blockquote>\n<p>Node.js + ES.next = ♥</p>\n</blockquote>\n<h3>Flow &amp;&amp; TypeScript</h3>\n<blockquote>\n<p>Type Systems Will Make You a Better JavaScript Developer</p>\n</blockquote>\n<h3>ES6模块</h3>\n<p>现在ES6自带了模块标准， 也是JS第一次支持module（之前的CommonJS、AMD、CMD都不算）， 但目前的所有Node.js版本都没有支持，目前只能用用Traceur、BabelJS， 或者TypeScript把ES6代码转化为兼容ES5版本的js代码，ES6模块新特性非常吸引人，下面简要说明。</p>\n<p>ES6 模块的目标是创建一个同时兼容CommonJS和AMD的格式，语法更加紧凑，通过编译时加载，使得编译时就能确定模块的依赖关系，效率要比 CommonJS 模块的加载方式高。而对于异步加载和配置模块加载方面，则借鉴AMD规范，其效率、灵活程度都远远好于CommonJS写法。</p>\n<ul>\n<li>语法更紧凑</li>\n<li>结构更适于静态编译（比如静态类型检查，优化等）</li>\n<li>对于循环引用支持更好</li>\n</ul>\n<p>ES6 模块标准只有2部分，它的用法更简单，你根本不需要关注实现细节:</p>\n<ul>\n<li>声明式语法：模块导入import、导出export，没有require了</li>\n<li>程式化加载API：可以配置模块是如何加载，以及按需加载。</li>\n</ul>\n<h3>多模块管理器：Lerna</h3>\n<blockquote>\n<p>A tool for managing JavaScript projects with multiple packages.</p>\n</blockquote>\n<p><a href=\"https://lernajs.io/\">https://lernajs.io/</a></p>\n<p>在设计框架的时候，经常做的事儿是进行模块拆分，继而提供插件或集成机制，这样是非常好的做法。但问题也随之而来，当你的模块模块非常多时，你该如何管理你的模块呢？</p>\n<ul>\n<li>法1：每个模块都建立独立的仓库</li>\n<li>法2：所有模块都放到1个仓库里</li>\n</ul>\n<p>法1虽然看起来干净，但模块多时，依赖安装，不同版本兼容等，会导致模块间依赖混乱，出现非常多的重复依赖，极其容易造成版本问题。这时法2就显得更加有效，对于测试，代码管理，发布等，都可以做到更好的支持。</p>\n<p>Lerna就是基于这种初衷而产生的专门用于管理Node.js多模块的工具，当然，前提是你有很多模块需要管理。</p>\n<p>你可以通过npm全局模块来安装Lerna，官方推荐直接使用Lerna 2.x版本</p>\n<h3>更好的NPM替代品：Yarn</h3>\n<p>Yarn是开源JavaScript包管理器，由于npm在扩展内部使用时遇到了大小、性能和安全等问题，Facebook携手来自Exponent、Google和Tilde的工程师，在大型JavaScript框架上打造和测试了Yarn，以便其尽可能适用于多人开发。Yarn承诺比各大流行npm包的安装更可靠，且速度更快。根据你所选的工作包的不同，Yarn可以将安装时间从数分钟减少至几秒钟。Yarn还兼容npm注册表，但包安装方法有所区别。其使用了lockfiles和一个决定性安装算法，能够为参与一个项目的所有用户维持相同的节点模块（node_modules）目录结构，有助于减少难以追踪的bug和在多台机器上复制。</p>\n<p>Yarn还致力于让安装更快速可靠，支持缓存下载的每一个包和并行操作，允许在没有互联网连接的情况下安装（如果此前有安装过的话）。此外，Yarn承诺同时兼容npm和Bower工作流，让你限制安装模块的授权许可。</p>\n<p>2016年10月份, Yarn在横空出世不到一周的时间里，github上的star数已经过万，可以看出大厂及社区的活跃度，以及解决问题的诚意，大概无出其右了！</p>\n<p>替换的原因</p>\n<ul>\n<li>在Facebook的大规模 npm 都工作的不太好</li>\n<li>npm拖慢了公司的ci工作流</li>\n<li>对一个检查所有的模块也是相当低效的</li>\n<li>npm被设计为是不确定性的，而Facebook工程师需要为他们的DevOps工作流提供一直和可依赖的系统</li>\n</ul>\n<p>与hack npm限制的做法相反，Facebook编写了Yarn</p>\n<ul>\n<li>Yarn 的本地缓存文件做的更好</li>\n<li>Yarn 可以并行它的一些操作，这加速了对新模块的安装处理</li>\n<li>Yarn 使用lockfiles，并用确定的算法来创建一个所有跨机器上都一样的文件</li>\n<li>出于安全考虑，在安装进程里，Yarn 不允许编写包的开发者去执行其他代码</li>\n</ul>\n<blockquote>\n<p>Yarn, which promises to even give developers that don’t work at Facebook’s scale a major performance boost, still uses the npm registry and is essentially a drop-in replacement for the npm client.</p>\n</blockquote>\n<p>很多人说和ruby的gem机制类似，都生成lockfile。确实是一个很不错的改进，在速度上有很大改进，配置cnpm等国内源来用，还是相当爽的。</p>\n<h3>友好语言</h3>\n<ul>\n<li>过气的Coffeescript，不多说</li>\n<li><a href=\"https://babeljs.io/\">Babel</a> - also an ES6 to ES5 transpiler that’s growing in popularity possibly because it also supports React’s JSX syntax. As of today it supports the most ES6 features at a somewhat respectable 73%.</li>\n<li><a href=\"http://www.typescriptlang.org/\">TypeScript</a> - a typed superset of JavaScript that not only compiles ES6 to ES5 (or even ES3) but also supports optional variable typing. TypeScript only supports 53% of ES6 features.</li>\n</ul>\n<h2>总结</h2>\n<blockquote>\n<p>坦诚的力量是无穷的</p>\n</blockquote>\n<p>Node.js是为异步而生的，它自己把复杂的事儿做了（高并发，低延时），交给用户的只是有点难用的Callback写法。也正是坦诚的将异步回调暴露出来，才有更好的流程控制方面的演进。也正是这些演进，让Node.js从DIRT（数据敏感实时应用）扩展到更多的应用场景，今天的Node.js已经不只是能写后端的JavaScript，已经涵盖了所有涉及到开发的各个方面，而Node全栈更是热门种的热门。</p>\n<p>直面问题才能有更好的解决方式，Node.js你值得拥有！</p>\n</div>","title":"2017，我们来聊聊 Node.js","last_reply_at":"2017-11-14T16:19:27.995Z","good":true,"top":true,"reply_count":166,"visit_count":73490,"create_at":"2017-04-13T02:41:41.818Z","author":{"loginname":"i5ting","avatar_url":"https://avatars3.githubusercontent.com/u/3118295?v=4&s=120"}},{"id":"58ad76db7872ea0864fedfcc","author_id":"51f0f267f4963ade0e08f503","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/FlwW5i2h_UuKpnBXXvD3AqyrwjHP\" alt=\"untitled4.png\"></p>\n<h1>饿了么大前端 Node.js 进阶教程</h1>\n<p>因为 2016 年面试了很多做 Node.js 的同学，发现大部分做 Node 的同学都是前端转过来的，对后端的知识大多一片空白。所以很难招到比较好的 Node.js 服务端程序员（注意，不是全栈）。</p>\n<p>于是出于我们一贯的开源与分享精神，我们筹备了这个名字叫《如何通过饿了么 Node.js 面试》的开源的 Node.js 进阶教程。</p>\n<p>github 仓库地址：<a href=\"https://github.com/ElemeFE/node-interview\">https://github.com/ElemeFE/node-interview</a></p>\n<h3>导读</h3>\n<p>本教程包含 2~3 年经验的 Node.js 服务端需要知道的知识点。</p>\n<p>需要注意的是, 并不适用于零基础的同学, 你需要有一定的 JavaScript/Node.js 基础, 并且有一定的工作经验. 另外本教程的重点更准确的说是服务端基础中 Node.js 程序员需要了解的部分.</p>\n<p>稳重将一些常见的问题划分归类, 每类标明涵盖的一些<code>覆盖点</code>, 并且列举几个<code>常见问题</code>, 通常这些问题都是 2~3 年工作经验需要了解或者面对的. 如果你对某类问题感兴趣, 或者想知道其中列举问题的答案, 可以通过该类下方的 <code>阅读更多</code> 查看更多的内容.</p>\n<p>整体上大纲列举的并不是很全面, 细节上覆盖率不高, 很多讨论只是点到即止, 希望大家带着问题去思考.</p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/js-basic.md\">Js 基础问题</a></h2>\n<blockquote>\n<p>与前端 Js 不同, 后端是直面服务器的, 更加偏向内存方面.</p>\n</blockquote>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/js-basic.md#%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD\"><code>[Basic]</code> 类型判断</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/js-basic.md#%E4%BD%9C%E7%94%A8%E5%9F%9F\"><code>[Basic]</code> 作用域</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/js-basic.md#%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92\"><code>[Basic]</code> 引用传递</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/js-basic.md#%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE\"><code>[Basic]</code> 内存释放</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/js-basic.md#es6-%E6%96%B0%E7%89%B9%E6%80%A7\"><code>[Basic]</code> ES6 新特性</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>js 中什么类型是引用传递, 什么类型是值传递? 如何将值类型的变量以引用的方式传递? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/js-basic.md#q-value\">[more]</a></li>\n<li>js 中， 0.1 + 0.2 === 0.3 是否为 true ? 在不知道浮点数位数时应该怎样判断两个浮点数之和与第三数是否相等？</li>\n<li>const 定义的 Array 中间元素能否被修改? 如果可以, 那 const 的意义是? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/js-basic.md#q-const\">[more]</a></li>\n<li>JavaScript 中不同类型以及不同环境下变量的内存都是何时释放? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/js-basic.md#q-mem\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/js-basic.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/module.md\">模块</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/module.md#%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6\"><code>[Basic]</code> 模块机制</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/module.md#%E7%83%AD%E6%9B%B4%E6%96%B0\"><code>[Basic]</code> 热更新</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/module.md#%E4%B8%8A%E4%B8%8B%E6%96%87\"><code>[Basic]</code> 上下文</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>a.js 和 b.js 两个文件互相 require 是否会死循环? 双方是否能导出变量? 如何从设计上避免这种问题? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/module.md#q-loop\">[more]</a></li>\n<li>如果 a.js require 了 b.js, 那么在 b 中定义全局变量 <code>t = 111</code> 能否在 a 中直接打印出来? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/module.md#q-global\">[more]</a></li>\n<li>如何在不重启 node 进程的情况下热更新一个 js/json 文件? 这个问题本身是否有问题? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/module.md#q-hot\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/module.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md\">事件/异步</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#promise\"><code>[Basic]</code> Promise</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#events\"><code>[Doc]</code> Events (事件)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#timers\"><code>[Doc]</code> Timers (定时器)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#%E9%98%BB%E5%A1%9E%E5%BC%82%E6%AD%A5\"><code>[Point]</code> 阻塞/异步</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#%E5%B9%B6%E8%A1%8C%E5%B9%B6%E5%8F%91\"><code>[Point]</code> 并行/并发</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>Promise 中 .then 的第二参数与 .catch 有什么区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#q-1\">[more]</a></li>\n<li>Eventemitter 的 emit 是同步还是异步? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#q-2\">[more]</a></li>\n<li>如何判断接口是否异步? 是否只要有回调函数就是异步? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#q-3\">[more]</a></li>\n<li>nextTick, setTimeout 以及 setImmediate 三者有什么区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#q-4\">[more]</a></li>\n<li>如何实现一个 sleep 函数? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#q-5\">[more]</a></li>\n<li>如何实现一个异步的 reduce? (注:不是异步完了之后同步 reduce) <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#q-6\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md\">进程</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md#process\"><code>[Doc]</code> Process (进程)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md#child-process\"><code>[Doc]</code> Child Processes (子进程)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md#cluster\"><code>[Doc]</code> Cluster (集群)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1\"><code>[Basic]</code> 进程间通信</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B\"><code>[Basic]</code> 守护进程</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>进程的当前工作目录是什么? 有什么作用? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md#q-cwd\">[more]</a></li>\n<li>child_process.fork 与 POSIX 的 fork 有什么区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md#q-fork\">[more]</a></li>\n<li>父进程或子进程的死亡是否会影响对方? 什么是孤儿进程? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md#q-child\">[more]</a></li>\n<li>cluster 是如何保证负载均衡的? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md#how-it-works\">[more]</a></li>\n<li>什么是守护进程? 如何实现守护进程? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md\">IO</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#buffer\"><code>[Doc]</code> Buffer</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#string-decoder\"><code>[Doc]</code> String Decoder (字符串解码)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#stream\"><code>[Doc]</code> Stream (流)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#console\"><code>[Doc]</code> Console (控制台)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#file\"><code>[Doc]</code> File System (文件系统)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#readline\"><code>[Doc]</code> Readline</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#repl\"><code>[Doc]</code> REPL</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>Buffer 一般用于处理什么数据? 其长度能否动态变化? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#buffer\">[more]</a></li>\n<li>Stream 的 highWaterMark 与 drain 事件是什么? 二者之间的关系是? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#%E7%BC%93%E5%86%B2%E5%8C%BA\">[more]</a></li>\n<li>Stream 的 pipe 的作用是? 在 pipe 的过程中数据是引用传递还是拷贝传递? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#pipe\">[more]</a></li>\n<li>什么是文件描述符? 输入流/输出流/错误流是什么? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#file\">[more]</a></li>\n<li>console.log 是同步还是异步? 如何实现一个 console.log? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#console\">[more]</a></li>\n<li>如何同步的获取用户的输入?  <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#%E5%A6%82%E4%BD%95%E5%90%8C%E6%AD%A5%E7%9A%84%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E7%9A%84%E8%BE%93%E5%85%A5\">[more]</a></li>\n<li>Readline 是如何实现的? (有思路即可) <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#readline\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md\">Network</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#net\"><code>[Doc]</code> Net (网络)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#udp\"><code>[Doc]</code> UDP/Datagram</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#http\"><code>[Doc]</code> HTTP</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#dns\"><code>[Doc]</code> DNS (域名服务器)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#zlib\"><code>[Doc]</code> ZLIB (压缩)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#rpc\"><code>[Point]</code> RPC</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>cookie 与 session 的区别? 服务端如何清除 cookie? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#q-cookie-session\">[more]</a></li>\n<li>HTTP 协议中的 POST 和 PUT 有什么区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#q-post-put\">[more]</a></li>\n<li>什么是跨域请求? 如何允许跨域? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#q-cors\">[more]</a></li>\n<li>TCP/UDP 的区别? TCP 粘包是怎么回事，如何处理? UDP 有粘包吗? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#q-tcp-udp\">[more]</a></li>\n<li><code>TIME_WAIT</code> 是什么情况? 出现过多的 <code>TIME_WAIT</code> 可能是什么原因? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#q-time-wait\">[more]</a></li>\n<li>ECONNRESET 是什么错误? 如何复现这个错误?</li>\n<li>socket hang up 是什么意思? 可能在什么情况下出现? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#socket-hang-up\">[more]</a></li>\n<li>hosts 文件是什么? 什么叫 DNS 本地解析?</li>\n<li>列举几个提高网络传输速度的办法?</li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md\">OS</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md#tty\"><code>[Doc]</code> TTY</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md#os\"><code>[Doc]</code> OS (操作系统)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md#path\"><code>[Doc]</code> Path</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0\"><code>[Doc]</code> 命令行参数</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md#%E8%B4%9F%E8%BD%BD\"><code>[Basic]</code> 负载</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md#checklist\"><code>[Point]</code> CheckList</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>什么是 TTY? 如何判断是否处于 TTY 环境? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md#tty\">[more]</a></li>\n<li>不同操作系统的换行符 (EOL) 有什么区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md#os\">[more]</a></li>\n<li>服务器负载是什么概念? 如何查看负载? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md#%E8%B4%9F%E8%BD%BD\">[more]</a></li>\n<li>ulimit 是用来干什么的? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md#ulimit\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md\">错误处理/调试/优化</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#errors\"><code>[Doc]</code> Errors (异常)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#domain\"><code>[Doc]</code> Domain (域)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#debugger\"><code>[Doc]</code> Debugger (调试器)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#c-c++-addon\"><code>[Doc]</code> C/C++ 插件</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#v8\"><code>[Doc]</code> V8</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#%E5%86%85%E5%AD%98%E5%BF%AB%E7%85%A7\"><code>[Point]</code> 内存快照</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#cpu-profiling\"><code>[Point]</code> CPU profiling</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>怎么处理未预料的出错? 用 try/catch ，domains 还是其它什么? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#q-handle-error\">[more]</a></li>\n<li>什么是 <code>uncaughtException</code> 事件? 一般在什么情况下使用该事件? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#uncaughtexception\">[more]</a></li>\n<li>domain 的原理是? 为什么要弃用 domain? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#domain\">[more]</a></li>\n<li>什么是防御性编程? 与其相对的 let it crash 又是什么?</li>\n<li>为什么要在 cb 的第一参数传 error? 为什么有的 cb 第一个参数不是 error, 例如 http.createServer?</li>\n<li>为什么有些异常没法根据报错信息定位到代码调用? 如何准确的定位一个异常? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#%E9%94%99%E8%AF%AF%E6%A0%88%E4%B8%A2%E5%A4%B1\">[more]</a></li>\n<li>内存泄漏通常由哪些原因导致? 如何分析以及定位内存泄漏? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#%E5%86%85%E5%AD%98%E5%BF%AB%E7%85%A7\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md\">测试</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md#%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95\"><code>[Basic]</code> 测试方法</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95\"><code>[Basic]</code> 单元测试</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md#%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95\"><code>[Basic]</code> 集成测试</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md#%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95\"><code>[Basic]</code> 基准测试</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md#%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95\"><code>[Basic]</code> 压力测试</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md#assert\"><code>[Doc]</code> Assert (断言)</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>为什么要写测试? 写测试是否会拖累开发进度?<a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md#q-why-write-test\">[more]</a></li>\n<li>单元测试的单元是指什么? 什么是覆盖率?<a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95\">[more]</a></li>\n<li>测试是如何保证业务逻辑中不会出现死循环的?<a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md#q-death-loop\">[more]</a></li>\n<li>mock 是什么? 一般在什么情况下 mock?<a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md#mock\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/util.md\">util</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/util.md#url\"><code>[Doc]</code> URL</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/util.md#query-strings\"><code>[Doc]</code> Query Strings (查询字符串)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/util.md#util-1\"><code>[Doc]</code> Utilities (实用函数)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/util.md#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F\"><code>[Basic]</code> 正则表达式</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>HTTP 如何通过 GET 方法 (URL) 传递 let arr = [1,2,3,4] 给服务器? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/util.md#get-param\">[more]</a></li>\n<li>Node.js 中继承 (util.inherits) 的实现? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/util.md#utilinherits\">[more]</a></li>\n<li>如何递归获取某个文件夹下所有的文件名? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/util.md#q-traversal\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/util.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md\">存储</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md#mysql\"><code>[Point]</code> Mysql</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md#mongodb\"><code>[Point]</code> Mongodb</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md#replication\"><code>[Point]</code> Replication</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md#%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7\"><code>[Point]</code> 数据一致性</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md#%E7%BC%93%E5%AD%98\"><code>[Point]</code> 缓存</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>备份数据库与 M/S, M/M 等部署方式的区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md#replication\">[more]</a></li>\n<li>索引有什么用，大致原理是什么? 设计索引有什么注意点? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md#%E7%B4%A2%E5%BC%95\">[more]</a></li>\n<li>Monogdb 连接问题(超时/断开等)有可能是什么问题导致的? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md#Mongodb\">[more]</a></li>\n<li>什么情况下数据会出现脏数据? 如何避免? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md#%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7\">[more]</a></li>\n<li>redis 与 memcached 的区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md#%E7%BC%93%E5%AD%98\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md\">安全</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#crypto\"><code>[Doc]</code> Crypto (加密)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#tlsssl\"><code>[Doc]</code> TLS/SSL</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#https\"><code>[Doc]</code> HTTPS</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#xss\"><code>[Point]</code> XSS</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#csrf\"><code>[Point]</code> CSRF</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB\"><code>[Point]</code> 中间人攻击</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#sqlnosql-%E6%B3%A8%E5%85%A5\"><code>[Point]</code> Sql/Nosql 注入</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>加密是如何保证用户密码的安全性? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#crypto\">[more]</a></li>\n<li>TLS 与 SSL 有什么区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#tlsssl\">[more]</a></li>\n<li>HTTPS 能否被劫持? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#https\">[more]</a></li>\n<li>XSS 攻击是什么? 有什么危害? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#xss\">[more]</a></li>\n<li>过滤 Html 标签能否防止 XSS? 请列举不能的情况? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#xss\">[more]</a></li>\n<li>CSRF 是什么? 如何防范? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#csrf\">[more]</a></li>\n<li>如何避免中间人攻击? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md\">阅读更多</a></p>\n<h2>最后</h2>\n<p>目前 repo 处于施工现场的情况，如果发现问题欢迎在 <a href=\"https://github.com/ElemeFE/node-interview/issues\">issues</a> 中指出。如果有比较好的<code>问题/知识点/指正</code>，也欢迎提 PR。</p>\n<p>另外关于 <code>Js 基础</code> 是个比较大的话题，在本教程不会很细致深入的讨论，更多的是列出一些重要或者更服务端更相关的地方，所以如果你拿着《JavaScript 权威指南》给教程提 PR 可能不会采纳。本教程的重点更准确的说是服务端基础中 Node.js 程序员需要了解的部分。</p>\n</div>","title":"饿了么大前端 Node.js 进阶教程","last_reply_at":"2017-11-14T09:09:38.265Z","good":true,"top":true,"reply_count":269,"visit_count":181454,"create_at":"2017-02-22T11:32:43.547Z","author":{"loginname":"lellansin","avatar_url":"https://avatars2.githubusercontent.com/u/2081487?v=4&s=120"}},{"id":"592917b59e32cc84569a7458","author_id":"54009f5ccd66f2eb37190485","tab":"share","content":"<div class=\"markdown-text\"><p>本来提供开发api，目的是为了开发第三方应用或客户端，如果大家用来学习也是好的，但现在很多人太过分了，随意发帖，at，严重影响了社区的用户，故而决定开始严查</p>\n<p>以下情况，直接封号</p>\n<ul>\n<li>测试标题</li>\n<li>无任何内容</li>\n<li>无意义回复</li>\n<li>测试帖，5分钟内没有删除</li>\n</ul>\n<p>欢迎大家监督</p>\n<p>封号</p>\n<ul>\n<li><a href=\"https://cnodejs.org/user/Mwangzhi\">https://cnodejs.org/user/Mwangzhi</a></li>\n<li><a href=\"https://cnodejs.org/user/lw6395\">https://cnodejs.org/user/lw6395</a></li>\n<li><a href=\"https://cnodejs.org/user/shengliang74\">https://cnodejs.org/user/shengliang74</a>  竟然挑衅，发帖说你来打我呀。。。。</li>\n<li><a href=\"https://cnodejs.org/user/h5-17\">https://cnodejs.org/user/h5-17</a> <a href=\"/user/h5-17\">@h5-17</a></li>\n<li><a href=\"https://cnodejs.org/user/592php\">https://cnodejs.org/user/592php</a> <a href=\"/user/592php\">@592php</a></li>\n</ul>\n<hr>\n<p>20170601更新</p>\n<p><a href=\"https://cnodejs.org/?tab=dev\">https://cnodejs.org/?tab=dev</a>  目前开了一个『客户端测试』专区，以后开发新客户端的同学，帖子直接发到这个专区去。tab 的值是 dev。</p>\n<p><img src=\"//dn-cnode.qbox.me/FundjyBuYk60yqQ-PdKstrPKY-7-\" alt=\"image.png\"></p>\n</div>","title":"测试请发到客户端测试专区，违规影响用户的，直接封号","last_reply_at":"2017-11-12T07:44:45.609Z","good":false,"top":true,"reply_count":127,"visit_count":27498,"create_at":"2017-05-27T06:07:49.278Z","author":{"loginname":"i5ting","avatar_url":"https://avatars3.githubusercontent.com/u/3118295?v=4&s=120"}},{"id":"59decbc461932717683d226c","author_id":"55895f5001d3ce0d73d69133","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/FitFsUGUKvy8rnoRWjjXYe0NRo1_\" alt=\"640.jpg\"></p>\n<h2>PPT精华</h2>\n<ul>\n<li><a href=\"https://ppt.baomitu.com/d/850e1d13#/\">https://ppt.baomitu.com/d/850e1d13#/</a> 地下铁第五期-未来从启动开始  张挺</li>\n<li><a href=\"https://ppt.baomitu.com/d/2e385fa0#/\">https://ppt.baomitu.com/d/2e385fa0#/</a> Openerable Node App 王子亭</li>\n<li><a href=\"https://ppt.baomitu.com/d/a2521d54#/\">https://ppt.baomitu.com/d/a2521d54#/</a> open-falcon在运维场景的应用和社区生态 高家升</li>\n<li><a href=\"https://ppt.baomitu.com/d/ff574384#/\">https://ppt.baomitu.com/d/ff574384#/</a> WebAssembly 在 Node.js 中的应用 傅晓嵩</li>\n<li><a href=\"https://ppt.baomitu.com/d/14fce0cd#/\">https://ppt.baomitu.com/d/14fce0cd#/</a> ThinkJS 3 的设计与运维 李成银</li>\n</ul>\n<hr>\n<p>我们不仅仅是开发者，也是维护者。</p>\n<p>Node 地下铁已经举办了四期，在不同的领域，我们进行了不少话题选择，而这次，我们的话题是“Ops First（可运维优先）”。</p>\n<p>谈起运维，我们自然都不陌生，它本身是一种职业，更是一种操守，一种负责任的态度，它讲究的不是说将自己的应用变的最好，而是如何稳定，可持续的维护下去。这种态度取决于使用何种方式来做，现有的 Node.js 体系下，我们已经有了一些方案，比如业界的各种集成平台，比如 Alinode，oneAPM 等，也有新兴的自建项目，致力于帮助开发者更好的掌控自己的应用，这些工具或多或少的在帮助应用的运维之路上提供了力所能及的帮助。</p>\n<p>了解并掌握这些工具，熟悉并对应用更有想法，这是在我看来，对维护，开发应用最好的诠释，也是对应用本身的未来，乃至未来接手的一系列维护者最好的礼物了。</p>\n<p>这次我们不一定聊到工具本身，工具只是载体，底层的数据采集，数据链路，数据分析，数据约定等等，每一项都是一门深奥的学问，每一个善于发现美的开发者一定会有自己独到的理解，会从中剖析出适合自己应用的方式，我们希望的，并不只是将工具拿回去应用，更希望能够让大家了解，为什么工具会这么做，应用如何变得更好，更稳定。</p>\n<p>我们挑选了五位嘉宾，跟着大家，一起聊聊将应用变的更好的故事，也期待着大家一起来书写，属于自己的故事。</p>\n<p>十月底，在北京，我们不见不散。</p>\n<p>时间：17-10-28（周六）13:30\n地点：北京·望京东园四区 9 号楼绿地中心 C 座 5F-14 岳麓书院</p>\n<p>话题：</p>\n<p>1、Open-Falcon 在运维场景的应用、接入及社区生态\n2、构建易于运维的 Node.js 后端\n3、ThinkJS 3 的设计与运维\n4、未来从应用启动开始\n5、Web Assembly 在 Node.js 中的最佳实践</p>\n<p>在话题结束后，我们会有一个关于 Ops First 的圆桌讨论，希望大家可以多多交流。</p>\n<p>大家赶紧报名吧。<a href=\"https://survey.alibaba.com/survey/A0QcwiwDR\">https://survey.alibaba.com/survey/A0QcwiwDR</a></p>\n<p>PS：场地有限，报名表单中对于 Ops First 话题提出独到见解和问题的同学优先通过。</p>\n</div>","title":"【PPT】「Ops First」 - Node 地下铁第五期线下沙龙分享和PPT","last_reply_at":"2017-11-08T03:14:33.650Z","good":true,"top":true,"reply_count":24,"visit_count":7357,"create_at":"2017-10-12T01:56:20.451Z","author":{"loginname":"hustxiaoc","avatar_url":"https://avatars3.githubusercontent.com/u/1102038?v=4&s=120"}},{"id":"59f0afd928137001719a821d","author_id":"59588bdf545d7a7b5b0b389f","tab":"share","content":"<div class=\"markdown-text\"><h2>validator.js</h2>\n<p>一个简单的数据验证对象，适用于浏览器与node环境。</p>\n<p><a href=\"https://github.com/mengdu/validator.js\">github</a></p>\n<p><a href=\"https://mengdu.github.io/validator.js\">文档</a></p>\n<p><a href=\"https://mengdu.github.io/validator.js/#/demo\">在线例子</a></p>\n<h2>use</h2>\n<p>install:</p>\n<pre class=\"prettyprint language-bat\"><code>npm install -S vdjs\n\n</code></pre><pre class=\"prettyprint language-js\"><code>const Validator = require(&#x27;vdjs&#x27;)\n\nvar valid = Validator.validate(data, {})\n\n</code></pre><p><strong>浏览器中使用</strong>:</p>\n<pre class=\"prettyprint language-html\"><code>&lt;script type=&quot;text&#x2F;javascript&quot; src=&quot;dist&#x2F;validator.min.js&quot;&gt;&lt;&#x2F;script&gt;\n\n</code></pre><h2>demo</h2>\n<pre class=\"prettyprint language-js\"><code>var validator = require(&#x27;.&#x2F;dist&#x2F;validator.js&#x27;)\n&#x2F;&#x2F; 待验证数据\nvar data = {\n  name: &#x27;validator&#x27;,\n  nickname: &#x27;validator.js&#x27;,\n  password: &#x27;123456&#x27;,\n  confirm_password: &#x27;1234561&#x27;\n}\n\n&#x2F;&#x2F; 验证数据\nvar valid = validator.validate(data, {\n  name: [\n    {required: true, msg: &#x27;name字段不能为空&#x27;},\n    {type: String, msg: &#x27;name字段必须是字符串&#x27;},\n    {length: [3, 20], msg: &#x27;name字段保持3~20字符&#x27;},\n  ],\n  nickname: {length: [3, 20], msg: &#x27;nickname字段保持3~20字符&#x27;},\n  password: {required: true, not: &#x27;123456&#x27;, min: 6, msg: &#x27;password验证不通过&#x27;},\n  confirm_password: {eq: data.password, msg: &#x27;两次输入密码不一致&#x27;}\n})\n\nconsole.log(valid.fails(), valid.valider(), valid.has(&#x27;name&#x27;), valid.all(true))\n\n</code></pre><h2>API</h2>\n<p><strong>validator</strong>：</p>\n<ul>\n<li>\n<p><code>validator.validate(data, constraints [, isOne])</code> 验证数据，返回验证结果对象Analyzer</p>\n<ul>\n<li><code>data</code> 待验证数据</li>\n<li><code>constraints</code> 数据限制要求</li>\n<li><code>isOne</code> 检查到错误字段即停止</li>\n</ul>\n</li>\n<li>\n<p><code>validator.pushRule(type, fun)</code> 添加规则</p>\n</li>\n<li>\n<p><code>validator.Rule[type](val, rval)</code> 验证，返回bool；如：<code>validator.Rule.between(50, [20, 100])</code> 返回 <code>true</code></p>\n</li>\n</ul>\n<p><strong>Analyzer</strong>：</p>\n<ul>\n<li><code>Analyzer.prototype.all(isArr)</code> 返回所有验证信息结果，对象；如果需要返回数组 <code>isArr</code> 为 <code>true</code> 即可。</li>\n<li><code>Analyzer.prototype.fails()</code> 检查是否失败，如果存在字段检查不通过，则返回true，反之false</li>\n<li><code>Analyzer.prototype.has(field)</code> 判断字段是否存在错误，返回Boolean</li>\n<li><code>Analyzer.prototype.get(field, isOrigin)</code> 获取字段错误信息</li>\n<li><code>Analyzer.prototype.first(field)</code> 返回指定字段的第一条错误信息</li>\n<li><code>Analyzer.prototype.last(field)</code> 返回指定字段的最后一条错误信息</li>\n<li><code>Analyzer.prototype.valider()</code> 返回验证对象</li>\n</ul>\n<h2>constraints</h2>\n<p><code>constraints</code> 数据限制</p>\n<p><strong>用法</strong>:</p>\n<pre class=\"prettyprint language-js\"><code>validator.validate(data, constraints)\n</code></pre><p><strong>constraints格式</strong>:</p>\n<pre class=\"prettyprint\"><code>字段: {规则名: 规则值, msg: &#x27;提示信息&#x27;}\n</code></pre><p><strong>例:</strong></p>\n<pre class=\"prettyprint language-js\"><code>{\n  name: {\n    required: true, msg: &#x27;用户名必须存在&#x27;\n  },\n  nickname: [\n    {required: true, not: &#x27;&#x27;, msg: &#x27;不能为空&#x27;}, &#x2F;&#x2F;可以存在两个rule，共用msg\n    {type: String, msg: &#x27;昵称必须是字符串&#x27;},\n    {length: [3, 20], msg: &#x27;昵称长度3~20字符，(包含3与20)&#x27;}\n  ]\n}\n</code></pre><h2>Rule</h2>\n<ul>\n<li><strong><code>required</code></strong> 验证字段必须存在，<code>undefined</code> 为不存在。</li>\n<li><strong><code>eq</code></strong> 值相等；<code>{eq: '123456', msg: '必须是123456'}</code>。</li>\n<li><strong><code>not</code></strong> 非。</li>\n<li><strong><code>type</code></strong> 符合的数据类型，支持 <code>String</code>, <code>Object</code>, <code>Array</code>, <code>Number</code>, <code>Boolean</code>, <code>Date</code>, …包括自定义对象  (除<code>null</code> , <code>undefined</code>)。</li>\n<li><strong><code>length</code></strong> 长度，支持数组与字符串数据；<code>{length: 6, msg: '值必须6位'}</code> 或者 <code>{length: [6, 20], msg: '6~20字符'}</code>。</li>\n<li><strong><code>min</code></strong> 大于等于，支持数字，字符串。</li>\n<li><strong><code>max</code></strong> 小于等于。</li>\n<li><strong><code>gt</code></strong> 大于 &gt; 。</li>\n<li><strong><code>gte</code></strong> 大于等于 &gt;= (同min)。</li>\n<li><strong><code>lt</code></strong> 小于 &lt; 。</li>\n<li><strong><code>lte</code></strong> 小于等于 &lt;= (同max)。</li>\n<li><strong><code>between</code></strong> 数字范围；<code>{between: [6, 20]}</code> 注：字符串比较问题 <code>'60' &gt;= '100'</code>；如：待验证值100，<code>{between: ['60', '100']}</code>。</li>\n<li><strong><code>notBetween</code></strong> 不在范围。</li>\n<li><strong><code>in</code></strong> 在里面，支持数组，对象，字符串；<code>{in: ['aa', 'bb']}</code>，<code>{in: 'this is a test', msg: ''}</code>。</li>\n<li><strong><code>notIn</code></strong> 不在里面。</li>\n<li><strong><code>match</code></strong> 匹配正则；<code>{match: /abc$/, msg: '必须以abc结尾'}</code>。</li>\n<li><strong><code>notMatch</code></strong> 不匹配正则。</li>\n<li><strong><code>like</code></strong> 模糊匹配，类似sql中的like规则；例如：<code>{like: 'abc%', '必须以abc开头'}</code> 。</li>\n<li><strong><code>notLike</code></strong> <code>like</code> 反义。</li>\n<li><strong><code>email</code></strong> 匹配邮箱；内部正则：<code>/^[A-Za-z0-9\\u4e00-\\u9fa5]+@[a-zA-Z0-9_-]+(\\.[a-zA-Z0-9_-]+)+$/</code>，可能存在一些不匹配情况。</li>\n<li><strong><code>upperCase</code></strong> 匹配大写。</li>\n<li><strong><code>lowerCase</code></strong> 匹配小写。</li>\n<li><strong><code>run</code></strong> 自定义执行过程，执行函数必须同步返回，暂不支持async/await；例如：<code>{run: (id) =&gt; {return true}, msg: ''}</code>。</li>\n</ul>\n<p><strong>required</strong></p>\n<p>在不提供 <code>required</code> 规则的情况或者<code>required: true</code> 时，只有data中对应字段不为undefined才会输出其他规则匹配结果。</p>\n<p>例如：</p>\n<pre class=\"prettyprint language-js\"><code>var data = {}\nvar valid = validator.validate(data, {\n  name: {length: 12, msg: &#x27;长度必须是12&#x27;}\n})\n</code></pre><p>这里 <code>valid.fails()</code> 结果是 <code>false</code> 的。</p>\n<pre class=\"prettyprint language-js\"><code>var data = {name: &#x27;abc&#x27;}\nvar valid = validator.validate(data, {\n  name: {length: 12, msg: &#x27;长度必须是12&#x27;}\n})\n</code></pre><p>这里 <code>valid.fails()</code> 结果是 <code>true</code> 的。</p>\n<p>以上两种情况，增加 <code>required: false</code> 是一样的结果。</p>\n<h2>自定义Rule</h2>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 添加回文规则\nvalidator.pushRule(&#x27;palindromic&#x27;, function (val, rval) {\n  if (rval) {\n    console.log(val.split(&#x27;&#x27;).reverse())\n    return val.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) === val\n  }\n  return true\n})\n\n</code></pre><h2>http请求验证例子</h2>\n<p>http请求需要注意的是空字段的问题，比如 <code>xxx?query=</code>， <code>query</code> 字段值是空的字符串，而不是null</p>\n<pre class=\"prettyprint language-js\"><code>var valid = validator.validate(ctx.request.body, {\n  email: [\n    {required: true, not: &#x27;&#x27;, msg: &#x27;邮箱不能为空&#x27;},\n    {match: &#x2F;^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+(.[a-zA-Z0-9_-])+&#x2F;, msg: &#x27;邮箱格式不对&#x27;}\n  ],\n  name: [\n    {required: true, not: &#x27;&#x27;, msg: &#x27;名字不能为空&#x27;}\n  ],\n  tel: [\n    {required: true, not: &#x27;&#x27;, msg: &#x27;电话号码不能为空&#x27;},\n    {match: &#x2F;^1[3|4|5|7|8][0-9]{9}$&#x2F;, msg: &#x27;手机号码格式不正确&#x27;}\n  ]\n})\n</code></pre><p>喜欢的朋友欢迎start交流，谢谢，打扰了。</p>\n</div>","title":"这样的validator.js是不是你想要的呢？","last_reply_at":"2017-11-15T05:30:36.949Z","good":false,"top":false,"reply_count":10,"visit_count":1958,"create_at":"2017-10-25T15:38:01.254Z","author":{"loginname":"mengdu","avatar_url":"https://avatars0.githubusercontent.com/u/11366654?v=4&s=120"}},{"id":"58d0dd8b17f61387400b7de5","author_id":"575eaa97c1518403160a45c4","tab":"share","content":"<div class=\"markdown-text\"><h1><a href=\"https://github.com/hyj1991/easy-monitor\">Easy-Monitor</a></h1>\n<p>Easy-Monitor是一个轻量级的Node项目性能监控工具，能在线上生产环境运行，主要帮助开发者找出执行时间最久或者超出预期的一系列函数，以及运行过程中v8引擎无法优化的一系列函数。</p>\n<p>这个项目源于之前做的解析v8-profiler日志命令行工具，有兴趣的可以看下之前的文章：</p>\n<p><a href=\"https://cnodejs.org/topic/58b562f97872ea0864fee1a7\">手把手测试你的JS代码性能</a></p>\n<p>按照之前所说的方式，对于开发者来说依旧非常的麻烦，并且不能进行线上运行时的调试，所以就整合集成了下诞生了Easy-Monitor。</p>\n<h2>I. 特点</h2>\n<ul>\n<li><strong>轻量级</strong></li>\n<li><strong>运行时</strong></li>\n<li><strong>无状态</strong></li>\n<li><strong>支持线上的cluster模式和多项目部署</strong></li>\n</ul>\n<h2>II. 三步快速开始</h2>\n<h3>安装</h3>\n<p>在控制台执行下面的命令安装：</p>\n<pre class=\"prettyprint language-bash\"><code>npm install easy-monitor\n</code></pre><h3>项目中引入</h3>\n<p>在你的项目入口文件中按照如下方式引入，传入你的项目名称：</p>\n<pre class=\"prettyprint language-js\"><code>const easyMonitor = require(&#x27;easy-monitor&#x27;);\neasyMonitor(&#x27;你的项目名称&#x27;);\n</code></pre><h3>访问监控页面</h3>\n<p>打开你的浏览器，输入以下地址，即可看到进程相关信息：</p>\n<pre class=\"prettyprint language-bash\"><code>http:&#x2F;&#x2F;127.0.0.1:12333\n</code></pre><p>以上三步即可开启你的专属性能监控服务，非常简单！</p>\n<h2>III. 定制化</h2>\n<p><code>Easy-Monitor</code> 也为大家保留了一些重要的属性可以方便定制化，依靠执行 <code>require('easy-monitor')(object)</code> 函数时传入一个对象，来替代默认传入的项目名称的字符串，这个传入的对象可以包含如下属性：</p>\n<ul>\n<li>\n<p><strong>logLevel</strong>：Number类型，默认是2，用来设置日志级别：</p>\n<ul>\n<li>0：不输出任何日志</li>\n<li>1：输出error日志</li>\n<li>2：输出info日志</li>\n<li>3：输出debug日志</li>\n</ul>\n</li>\n<li>\n<p><strong>appName</strong>：String类型，默认是 process.title 获取到的值，用来设置项目名称</p>\n</li>\n<li>\n<p><strong>httpServerPort</strong>：Numver类型，默认是 12333，用来设置监控HTTP服务器的侦听端口</p>\n</li>\n<li>\n<p><strong>filterFunction</strong>：函数，默认将profiling的结果中过滤掉了包含node_modules、anonymous以及路径中不包含 “/” 的系统函数，开发者可以自己编写过滤函数来找出自己想要的结果，入参和返回值：</p>\n<ul>\n<li>filePath：String类型，profiling结果函数所在的文件全路径</li>\n<li>funcName：String类型，pfofiling结果函数的名称</li>\n<li>返回值：为true表示保留结果，false表示过滤掉</li>\n</ul>\n</li>\n<li>\n<p><strong>monitorAuth</strong>：函数，默认不鉴权，用来进行登入监控页面的鉴权，开发者可以自己编写鉴权函数，入参和返回值：</p>\n<ul>\n<li>user：String类型，为用户名</li>\n<li>pass：String类型，为用户键入密码</li>\n<li>返回值：Promise对象实例，resolve(true)表示鉴权通过，resolve(false)或者reject表示鉴权失败</li>\n</ul>\n</li>\n</ul>\n<h2>IV. 监控页面一览</h2>\n<h3>1. 首页</h3>\n<h4>a. 查看整个项目</h4>\n<p><img src=\"//dn-cnode.qbox.me/FnOnNJjc9AsVOMZqevsHqlns7K47\" alt=\"Index_Project.jpeg\"></p>\n<p>如图，点击项目名称，则会对 <strong>整个项目</strong> 所有的进程进行profiling操作，这个所有进程包含：</p>\n<ul>\n<li>单进程模式下则只有一个主进程</li>\n<li>cluster模式下所有的子进程</li>\n</ul>\n<h4>b. 查看项目下某一个子进程</h4>\n<p><img src=\"//dn-cnode.qbox.me/FoW6H8QpWmFDWxEGid4LzXQfL6_I\" alt=\"Index_Pid.jpeg\"></p>\n<p>如图，在cluster模式下项目会有多个子进程，点击某一个特定的pid，则只会对 <strong>此pid对应的子进程</strong> 进行profiling操作。</p>\n<h4>c. 多项目部署</h4>\n<p><img src=\"//dn-cnode.qbox.me/FmR6Bv32tyZR6Rf1yYIy9OF0PKxr\" alt=\"Index_Multi.jpeg\"></p>\n<p>如图，<code>Easy-Monitor</code> <strong>支持多项目部署</strong>，用法和单项目是一模一样的，可以参考前面的快速开始。那么多项目启动后，监控页面会展示出不同的项目名称和对应的子进程pid。</p>\n<h3>2. 监控详情页</h3>\n<h4>a. 执行时间超出预期的函数列表</h4>\n<p><img src=\"//dn-cnode.qbox.me/FlaESADt9AZ3ohKXwQeiTfJvCLY7\" alt=\"Detail_Long.jpeg\"></p>\n<p>如图，可以追加 <code>querystring</code> 参数的形式自定义预期时间以及展示的条数，如下：</p>\n<ul>\n<li><code>?timeout=你预期的时间(ms)</code></li>\n<li><code>?long_limit=你想展示的条数</code></li>\n<li><code>?timeout=你预期的时间(ms)&amp;long_limit=你想展示的条数</code></li>\n</ul>\n<h4>b. 耗费时间最久的函数列表</h4>\n<p><img src=\"//dn-cnode.qbox.me/FhpDcFU36iEYUkxC3nvv9bIrRlDY\" alt=\"Detail_Top.jpeg\"></p>\n<p>如图，可以追加 <code>querystring</code> 参数的形式自定义展示条数，如下：</p>\n<ul>\n<li><code>?top_limit=你想展示的条数</code></li>\n</ul>\n<h4>c. v8引擎无法优化的函数列表</h4>\n<p><img src=\"//dn-cnode.qbox.me/FrBFxsxO8Vle6LFcSha4V10M2lz1\" alt=\"Detail_Bail.jpeg\"></p>\n<p>如图，可以追加 <code>querystring</code> 参数的形式自定义展示条数，如下：</p>\n<ul>\n<li><code>?bail_limit=你想展示的条数</code></li>\n</ul>\n<h2>V. 测试</h2>\n<p><a href=\"https://github.com/hyj1991/easy-monitor\">git clone</a>下本代码后，使用npm安装依赖，然后执行如下测试脚本：</p>\n<pre class=\"prettyprint\"><code>npm run test\n</code></pre><p>即可看到覆盖率测试报告。</p>\n<h2>VI. 结语</h2>\n<p>最后项目地址为：<a href=\"https://github.com/hyj1991/easy-monitor\">Easy-Monitor</a></p>\n<p>欢迎大家提issue，或者一起开发完善，如果感觉不错，赏个star也是很开心的事情~</p>\n</div>","title":"轻量级易部署Node性能监控工具：Easy-Monitor","last_reply_at":"2017-11-15T05:22:49.344Z","good":false,"top":false,"reply_count":20,"visit_count":4410,"create_at":"2017-03-21T08:00:11.803Z","author":{"loginname":"hyj1991","avatar_url":"https://avatars2.githubusercontent.com/u/19908330?v=4&s=120"}},{"id":"5a0bcdf0f9c5b3853958d923","author_id":"58d866b86f8b9bf02d1d0b20","tab":"ask","content":"<div class=\"markdown-text\"><p>近期想去找找 inquirer 这个模块 是如何实现的。。貌似这个inquirer 是一个各个模块的集合， 有没有前辈研究过这个，，下载下来里面只是些例子，可我想知道具体是如何实现的。 或者前辈给我指一个方向\n万分感谢。</p>\n</div>","title":"rx-lite-aggregates 这个模块有没有人用过 ，或者inquirer，命令行交互相关的","last_reply_at":"2017-11-15T05:17:36.288Z","good":false,"top":false,"reply_count":0,"visit_count":21,"create_at":"2017-11-15T05:17:36.288Z","author":{"loginname":"wjiban","avatar_url":"https://avatars3.githubusercontent.com/u/23730727?v=4&s=120"}},{"id":"5a057fc1ee9b35da75a86a32","author_id":"5966cfadb3b22664747cc895","tab":"share","content":"<div class=\"markdown-text\"><h3>front-end</h3>\n<pre class=\"prettyprint language-js\"><code>webpack --color --watch\n</code></pre><h4>这样前端文件修改后，webpack会watch，</h4>\n<h3>back-end</h3>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F;koa-static 加载静态文件\napp.use(koaStatic( path.resolve(&#x27;.&#x2F;dist&#x27;), {\n    maxAge: 356 * 24 * 60 * 60\n}))\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\npm2 start app.js --watch\npm2 log\n</code></pre><h4>这样后端文件修改了后，PM2 会自动重启nodejs，PM2 log 查看最新日志</h4>\n<p><img src=\"//dn-cnode.qbox.me/FmOzeVt_n2mBvhAU4TaDxDzD1n4a\" alt=\"image.png\"></p>\n</div>","title":"突然发现个(webpack+nodejs)的热部署","last_reply_at":"2017-11-15T04:59:53.559Z","good":false,"top":false,"reply_count":7,"visit_count":559,"create_at":"2017-11-10T10:30:25.183Z","author":{"loginname":"pengliheng","avatar_url":"https://avatars2.githubusercontent.com/u/14355994?v=4&s=120"}},{"id":"5a0aae91a57c17282e120665","author_id":"576d050fbef3ca5c17dedf8b","tab":"ask","content":"<div class=\"markdown-text\"><p>买来发现根本不让远程链接，环境都是他预先设置好的，node,mongo这些根本没法装。是不是可以申请退一波款了?</p>\n</div>","title":"阿里云的云虚拟主机是不是不能自定义安装环境？","last_reply_at":"2017-11-15T04:47:41.763Z","good":false,"top":false,"reply_count":4,"visit_count":225,"create_at":"2017-11-14T08:51:29.073Z","author":{"loginname":"qichangjun","avatar_url":"https://avatars2.githubusercontent.com/u/15797310?v=4&s=120"}},{"id":"5a0545cb88c853c52fd5682a","author_id":"58edae8949056f03483477e8","tab":"ask","content":"<div class=\"markdown-text\"><p>我在维护一个论坛,数据库打算更换到mongodb, 然后遇到了这样一些问题\n查询大概是这样的步骤:</p>\n<pre class=\"prettyprint\"><code>数据表T,  数组A[objectid关联 表T]\n1.筛选T得到结果1;\n2.从数组A中拓展得到结果2;\n3.合并结果1结果2,得到结果3;\n4.筛选排序结果3,得到最终结果;\n</code></pre><p>第一个问题: 这样的查询MONGO怎么实现?\n第二个问题: 在aggregate中如何返回这种结果(分页)</p>\n<pre class=\"prettyprint\"><code>{\n\tlength: x,\n\tdocuments: [\n\t\tdoc1,\n\t\t...\n\t]\n}\n</code></pre></div>","title":"请教大家一个数据库设计的问题","last_reply_at":"2017-11-15T03:40:16.035Z","good":false,"top":false,"reply_count":8,"visit_count":553,"create_at":"2017-11-10T06:23:07.025Z","author":{"loginname":"lzszone","avatar_url":"https://avatars0.githubusercontent.com/u/16443301?v=4&s=120"}},{"id":"5a0bb204f9c5b3853958d91e","author_id":"597ee3db68aa87c774e5edac","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/FqT9W3yc1-H7Wqoqb1Pzy4mJFQwP\" alt=\"Slice 8.png\"></p>\n<p><a href=\"https://thinkjs.org/doc/index.html\">ThinkJS 3.0</a> 是一款面向未来开发的 Node.js 框架，内核基于 <a href=\"http://koajs.com/\">Koa 2.0</a>。 3.0 相比 2.0 版本进行了模块化改造，使得内核本身只包含了最少量必须的代码，甚至还不足以构成一个完整的 Web MVC 框架，除了内核里面实现的 Controller， View 和 Model 被实现为<a href=\"https://thinkjs.org/zh-cn/doc/3.0/extend.html\">扩展</a>（Extend）模块 <a href=\"https://thinkjs.org/zh-cn/doc/3.0/view.html\">think-view</a> 和 <a href=\"https://thinkjs.org/zh-cn/doc/3.0/relation_model.html\">think-model</a>，这样实现的好处也是显而易见的，如果我的 Web 服务只是简单的 RESTful API，就不需要引入 View 层，让代码保持轻快。</p>\n<h2>think-cli 2.0 新版发布</h2>\n<p>在本文发布的同时 ThinkJS 团队发布了新版的脚手架 <a href=\"https://github.com/thinkjs/think-cli\">think-cli 2.0</a>，新版脚手架最大的特点是脚手架和模板分离，可以在不修改脚手架的基础上添加各种<a href=\"https://github.com/think-template\">项目启动模板</a>，如果老司机想跳过下面实现细节，快速开始尝试 TypeScript 下的 ThinkJS 3.0， 可以用 think-cli 2.0 和 TypeScript 的官方模板：</p>\n<pre class=\"prettyprint\"><code>npm install -g thinkjs-cli@2\nthinkjs new project-name typescript\n</code></pre><p>&lt;!–more–&gt;</p>\n<h2>实现支持 TypeScript</h2>\n<p>TypeScript 是 JavaScript 的超集，其最大的的特性是引入了静态类型检查，按照一般的经验，在中大型的项目上引入 TypeScript 收获显著，并有相当的使用群体，这也就坚定了 ThinkJS 3.0 支持 TypeScript 的决心。我们希望 TS 版本的代码对用户的侵入尽可能的小，配置足够简单，并且接口定义准确，清晰。基于这样的目的，本文在接下来的章节会探讨在实现过程中的一些思考和方案。</p>\n<h3>继承 Koa 的定义</h3>\n<p>因为 ThinkJS 3.0 基于 <a href=\"http://koajs.com/\">Koa</a>，我们需要把类型定义构建在其定义之上，大概的思路就是用继承的方式定义 ThinkJS 自己的接口并添加自己的扩展实现，最后再组织起来。话是这么说，还是赶紧写点代码验证一下。发现 Koa 的 TS 定义没有自己实现而是在 <a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped\">DefinitelyTyped</a> 里面，这种情况多数是库的作者没有实现 TypeScript 接口定义，由社区的伙伴实现出来了并上传，方便大家使用，而 ThinkJS 本身计划支持 TypeScript，所有后面的实现都是定义在项目的 index.d.ts 文件里面。好回到代码，首先安装 Koa 和类型定义。</p>\n<p><code>npm install koa @types/koa</code></p>\n<p>然后在 ThinkJS 项目里面添加 index.d.ts， 并在 <code>package.json</code> 里面添加 <code>&quot;type&quot;: &quot;index.d.ts&quot;,</code>，这样 IDE （比如 <a href=\"https://code.visualstudio.com/\">VSCode</a>）就能知道这个项目的类型定义文件的位置，我们需要一个原型来验证想法的可行性：</p>\n<pre class=\"prettyprint language- js\"><code>  &#x2F;&#x2F; in thinkjs&#x2F;index.d.ts\n  \n  import * as Koa from &#x27;koa&#x27;;\n    \n  interface Think {\n    app: Koa;\n  }\n  &#x2F;&#x2F; expect think to be global variable\n  declare var think: Think;\n</code></pre><pre class=\"prettyprint language- js\"><code>  &#x2F;&#x2F; in Controller\n  \n  import ”thinkjs“;\n  &#x2F;&#x2F; bellow will cause type error\n  think.app\n</code></pre><p>出师不利，这样的定义是不能正常工作的，IDE 的输入感知也不会生效，原因是 TypeScript 为了避免全局污染，严格区分模块 scope 和全局定义的 scope， 一旦使用了 <code>import</code> 或者 <code>export</code> 就会认为是模块，<code>think</code> 变量就只存在于模块 scope 里面了。仔细一想这种设定也合理，于是修改代码，改成模块。改成模块后与JS版本的区别是 TypeScript 里面需要显式获取 <code>think</code> 对象:</p>\n<pre class=\"prettyprint language- js\"><code>  &#x2F;&#x2F; in thinkjs&#x2F;index.d.ts\n  \n  import * as Koa from &#x27;koa&#x27;;\n  \n  declare namespace ThinkJS {\n    interface Think {\n      app: Koa;\n    }\n    export var think: Think;\n  }\n  export = ThinkJS\n</code></pre><pre class=\"prettyprint language- js\"><code>  &#x2F;&#x2F; in Controller\n  import { think } from ”thinkjs“;\n\n  &#x2F;&#x2F; working!\n  think.app\n</code></pre><p>经过验证果然行得通，准备添加更多实现。</p>\n<h3>基本雏形</h3>\n<p>接下来先实现一版基本的架子，这个架子基本上反应了 ThinkJS 里面最重要的类和他们之间的关系。</p>\n<pre class=\"prettyprint language-js\"><code>\nimport * as Koa from &#x27;koa&#x27;;\nimport * as Helper from &#x27;think-helper&#x27;;\nimport * as ThinkCluster from &#x27;think-cluster&#x27;;\n\ndeclare namespace &#x27;ThinkJS&#x27; {\n\n  export interface Application extends Koa {\n    think: Think;\n    request: Request;\n    response: Response;\n  }\n\n  export interface Request extends Koa.Request {\n  }\n\n  export interface Response extends Koa.Response {\n  }\n\n  export interface Context extends Koa.Context {\n    request: Request;\n    response: Response;\n  }\n\n  export interface Controller {\n    new(ctx: Context): Controller;\n    ctx: Context;\n    body: any;\n  }\n\n  export interface Service {\n    new(): Service;\n  }\n\n  export interface Logic {\n    new(): Logic;\n  }\n\n  export interface Think extends Helper.Think {\n    app: Application;\n    Controller: Controller;\n    Logic: Logic;\n    Service: Service; \n  }\n\n  export var think: Think;\n}\n \n\nexport = ThinkJS;\n\n</code></pre><p>这里面定义到的类都是 ThinkJS 里面支持扩展的类型，为了简洁起见省略了许多方法和字段的定义，需要指出的是 <code>Controller</code>， <code>Service</code>， <code>Logic</code> 这三个接口需要被继承 <code>extends</code>，要求实现构造器并返回本身类型的一个实例。架子基本确定，开始定义接口。</p>\n<h3>定义接口</h3>\n<p>定义接口是整个实现最难的部分，在过程中走了不少弯路。主要原因是 <code>ThinkJS 3.0</code> 高度模块化，程序里面用到的 Extend 方法都由具体模块生成，我们的实现方案也经历了几个阶段，简单列举一下这个过程。</p>\n<h4>全量定义</h4>\n<p>这是第一阶段 ThinkJS 3.0 支持 TypeScript 的方案， 当时对全局 scope 和模块 scope 的问题还不是很清晰，以至于一些想法得不到验证，也渐渐偏离了最佳的方案。当时考虑到扩展模块不是很多，直接全量定义所有扩展接口，这样用户不管有没有引入某个 Extend 模块，都能获得模块的接口提示。这样做的弊端有很多，比如无法支持项目内 Extend 等，但这个方案的好处是需要用户关注的东西最少，代码开箱即用。</p>\n<h4>增量模块</h4>\n<p>我们清楚按需引入才是最理想的方案，后来我们发现 TypeScript 有一个特性叫 <a href=\"https://www.typescriptlang.org/docs/handbook/declaration-merging.html\">Module Augmentation</a> ，其实这个特性最大用处就是可以在不同模块扩充某一个模块的接口定义，让增量模块定义生效很重要的一点前提是，需要用户在文件中显式加载对应的模块，也就是让 TypeScript 知道谁对模块实现了增量定义。比如，要想获得 <code>think-view</code> 定义的增量接口，需要在 <code>Controller</code> 实现中引入：</p>\n<pre class=\"prettyprint language- js\"><code>import { think } from &quot;thinkjs&quot;;\nimport &quot;think-view&quot;;\n&#x2F;&#x2F; import &quot;think-model&quot;;\nexport default class extends think.Controller {\n  indexAction() {\n    this.model();  &#x2F;&#x2F; reports an error\n    this.display(); &#x2F;&#x2F; OK\n  }\n}\n</code></pre><pre class=\"prettyprint language- js\"><code>&#x2F;&#x2F; in think-view\ndeclare module &#x27;thinkjs&#x27; {\n  interface Controller {\n    dispay(): void\n  }\n}\n</code></pre><pre class=\"prettyprint language- js\"><code>&#x2F;&#x2F; in think-model\ndeclare module &#x27;thinkjs&#x27; {\n  interface Controller {\n    model(): void\n  }\n}\n</code></pre><p>这样写很麻烦，但如果不去 <code>import</code> TypeScript 是无法完成提示和追溯的，一个简化版本是我们可以在一个文件里面定义所有的用到的 <code>Extend</code> 模块，并输出 <code>think</code> 对象，比如</p>\n<pre class=\"prettyprint language- js\"><code>&#x2F;&#x2F; think.js\nimport { think } from &quot;thinkjs&quot;;\nimport &quot;think-view&quot;;\nimport &quot;think-model&quot;;\n&#x2F;&#x2F; import the rest extend module\n&#x2F;&#x2F; import project exnted files\nexport default think;\n</code></pre><pre class=\"prettyprint language- js\"><code>&#x2F;&#x2F; some_controller.js\nimport think from &#x27;.&#x2F;think.js&#x27;;\nexport default class extends think.Controller {\n  indexAction() {\n    this.model();\n    this.display();\n  }\n}\n</code></pre><p>这样问题已经基本解决了，只是用了相对路径，如果在多级目录下路径就比较凌乱，有没有更好的方案呢？</p>\n<h4>黑科技：path</h4>\n<p>我们知道 Webpack 里面有一个非常好用的功能是 <code>alias</code>，就是用来解决相对路径引用问题的，发现 TypeScript 也有类似概念叫 <code>compilerOptions.path</code>，相当于对某个路径定义了一个缩写，这样只要对刚才的定义文件添加到 <code>compilerOptions.path</code> 里面，并且缩写名称叫 <code>thinkjs</code> （定义成 thinkjs 这样编译后就能正常运行, 下面会提到)，那 Controller 的实现就毫无违和感了：</p>\n<pre class=\"prettyprint language- js\"><code>import {think} from &#x27;thinkjs&#x27;;\nexport default class extends think.Controller {\n  indexAction() {\n    this.model();\n    this.display();\n  }\n}\n</code></pre><pre class=\"prettyprint language- js\"><code>import * as ThinkJS from &#x27;..&#x2F;node_modules&#x2F;thinkjs&#x27;;\nimport &#x27;think-view&#x27;;\nimport &#x27;think-model&#x27;;\n\n&#x2F;&#x2F; other extend modules\n&#x2F;&#x2F; ...\nexport const think = ThinkJS.think;\n</code></pre><p>注意到这里 ThinkJS 是通过相对路径引用的，因为 <code>'thinkjs'</code> 模块已经被重定向，这里还需要一个小小的黑科技来骗过 TypeScript 让其知道模块 <code>'../node_modules/thinkjs'</code> 是 <code>‘thinkjs'</code>，</p>\n<pre class=\"prettyprint language- js\"><code>  &#x2F;&#x2F; in thinkjs&#x2F;index.d.ts\n\n  import { Think } from &#x27;thinkjs&#x27;;\n  \n  &#x2F;&#x2F; this is a external module\n  declare module ‘thinkjs’ {\n    &#x2F;&#x2F; put all declaration in here\n  }\n\n  &#x2F;&#x2F; curently TypeScript think this is in &#x27;..&#x2F;node_modules&#x2F;thinkjs&#x27; module\n  declare namespace ThinkJS {\n    export var think: Think;\n  }\n\n  export = ThinkJS;\n\n</code></pre><p>对于实现，其实我们更关心接口的优雅，也许后面有更合理的实现，但是前提是写法要保持简洁。</p>\n<h3>引入项目扩展</h3>\n<p>项目里面的扩展同样使用增量模块定义，代码如下</p>\n<pre class=\"prettyprint language- js\"><code>declare module &#x27;thinkjs&#x27; {\n  export interface Controller {\n    yourControllerExtend(): void\n  }\n}\n\nconst controller = {\n  yourControllerExtend() {\n    &#x2F;&#x2F; do something\n  }\n};\n\nexport default controller;\n</code></pre><p>ThinkJS 支持扩展的对象总共有8个，为了方便，在 <a href=\"https://github.com/thinkjs/think-cli#\">think-cli 2.0 </a> 版本中，TypeScript 的<a href=\"https://github.com/think-template/typescript\">官方模板</a>默认生成所有对象的定义,并在 <code>src/index.ts</code> 里面引入。</p>\n<pre class=\"prettyprint language- js\"><code>\nimport * as ThinkJS from &#x27;..&#x2F;node_modules&#x2F;thinkjs&#x27;;\n\nimport &#x27;.&#x2F;extend&#x2F;controller&#x27;;\nimport &#x27;.&#x2F;extend&#x2F;logic&#x27;;\nimport &#x27;.&#x2F;extend&#x2F;context&#x27;;\nimport &#x27;.&#x2F;extend&#x2F;think&#x27;;\nimport &#x27;.&#x2F;extend&#x2F;service&#x27;;\nimport &#x27;.&#x2F;extend&#x2F;application&#x27;;\nimport &#x27;.&#x2F;extend&#x2F;request&#x27;;\nimport &#x27;.&#x2F;extend&#x2F;response&#x27;; \n\n&#x2F;&#x2F; import the rest extends modules on need\n\nexport const think = ThinkJS.think;\n</code></pre><h3>完善接口</h3>\n<p>最后就是一些接口的定义和添加文档，相当于从源代码结合着文档，把所有 ThinkJS 3.0 的接口都定义出来, 最终目的是能提供一个清晰的开发接口提示，举个例子</p>\n<pre class=\"prettyprint language- js\"><code>*\n* get config\n* @memberOf Controller\n*&#x2F;\nconfig(name: string): Promise&lt;string&gt;;\n&#x2F;**\n * set config\n * @memberOf Controller\n *&#x2F;\nconfig(name: string, value: string): Promise&lt;string&gt;;\n</code></pre><h3>TSLint</h3>\n<p>我们基于 ThinkJS 项目的特点配置了一套 tslint 的规则并保证开箱代码符合规范。</p>\n<h3>编译部署</h3>\n<p>在开发环境可以使用 <code>think-typescript</code> 编译，还支持 <code>tsc</code> 直接编译，之前 <code>import { think } from 'thinkjs'</code> 会被编译为</p>\n<pre class=\"prettyprint language- js\"><code>const thinkjs_1 = require(&quot;thinkjs&quot;);\nclass default_1 extends thinkjs_1.think.Controller {\n</code></pre><p>这个路径并没有按照 <code>compileOptions.path</code> 的配置进行相对路径的计算，但是不管哪种方式都能正常工作，而且当前方式的结果更为理想，只是要求缩写名一定是 thinkjs 。</p>\n<h2>最后</h2>\n<p>在用 VSCode 开发 TypeSccript 的 ThinkJS 3.0 过程中，能获得智能感知和更多的错误提示，感觉代码得到了更多的保护和约束，有点之前在后端写 Java 的体验，如果还没有尝试过 TypeScript 的同学，赶紧来试试吧。</p>\n</div>","title":"ThinkJS 3.0 如何实现对 TypeScript 的支持","last_reply_at":"2017-11-15T03:18:28.972Z","good":false,"top":false,"reply_count":0,"visit_count":92,"create_at":"2017-11-15T03:18:28.972Z","author":{"loginname":"lizheming","avatar_url":"https://avatars2.githubusercontent.com/u/424491?v=4&s=120"}},{"id":"5a0bac23ef333d0e2e61a074","author_id":"54bc7fde0049cbcc5994c51f","tab":"ask","content":"<div class=\"markdown-text\"><p>兄弟们推荐一个百万级高并发开源项目，最好是node</p>\n<ul>\n<li>mysql + redis 或者 php + mysql + redis</li>\n</ul>\n<p>From <a href=\"https://github.com/soliury/noder-react-native\">Noder</a></p>\n</div>","title":"兄弟们推荐一个百万级高并发开源项目","last_reply_at":"2017-11-15T03:12:21.834Z","good":false,"top":false,"reply_count":1,"visit_count":126,"create_at":"2017-11-15T02:53:23.155Z","author":{"loginname":"einsqing","avatar_url":"https://avatars3.githubusercontent.com/u/7685948?v=4&s=120"}},{"id":"5a014cbe235953e84e47d543","author_id":"5110f2bedf9e9fcc584e4677","tab":"share","content":"<div class=\"markdown-text\"><p>Promise 想必大家十分熟悉，想想就那么几个 api，可是你真的了解 Promise 吗？本文根据 Promise 的一些知识点总结了十道题，看看你能做对几道。</p>\n<h3>题目一</h3>\n<pre class=\"prettyprint language-js\"><code>const promise = new Promise((resolve, reject) =&gt; {\n  console.log(1)\n  resolve()\n  console.log(2)\n})\npromise.then(() =&gt; {\n  console.log(3)\n})\nconsole.log(4)\n</code></pre><h3>题目二</h3>\n<pre class=\"prettyprint language-js\"><code>const promise1 = new Promise((resolve, reject) =&gt; {\n  setTimeout(() =&gt; {\n    resolve(&#x27;success&#x27;)\n  }, 1000)\n})\nconst promise2 = promise1.then(() =&gt; {\n  throw new Error(&#x27;error!!!&#x27;)\n})\n\nconsole.log(&#x27;promise1&#x27;, promise1)\nconsole.log(&#x27;promise2&#x27;, promise2)\n\nsetTimeout(() =&gt; {\n  console.log(&#x27;promise1&#x27;, promise1)\n  console.log(&#x27;promise2&#x27;, promise2)\n}, 2000)\n</code></pre><h3>题目三</h3>\n<pre class=\"prettyprint language-js&#x27;\"><code>const promise = new Promise((resolve, reject) =&gt; {\n  resolve(&#x27;success1&#x27;)\n  reject(&#x27;error&#x27;)\n  resolve(&#x27;success2&#x27;)\n})\n\npromise\n  .then((res) =&gt; {\n    console.log(&#x27;then: &#x27;, res)\n  })\n  .catch((err) =&gt; {\n    console.log(&#x27;catch: &#x27;, err)\n  })\n</code></pre><h3>题目四</h3>\n<pre class=\"prettyprint language-js\"><code>Promise.resolve(1)\n  .then((res) =&gt; {\n    console.log(res)\n    return 2\n  })\n  .catch((err) =&gt; {\n    return 3\n  })\n  .then((res) =&gt; {\n    console.log(res)\n  })\n</code></pre><h3>题目五</h3>\n<pre class=\"prettyprint language-js\"><code>const promise = new Promise((resolve, reject) =&gt; {\n  setTimeout(() =&gt; {\n    console.log(&#x27;once&#x27;)\n    resolve(&#x27;success&#x27;)\n  }, 1000)\n})\n\nconst start = Date.now()\npromise.then((res) =&gt; {\n  console.log(res, Date.now() - start)\n})\npromise.then((res) =&gt; {\n  console.log(res, Date.now() - start)\n})\n</code></pre><h3>题目六</h3>\n<pre class=\"prettyprint language-js\"><code>Promise.resolve()\n  .then(() =&gt; {\n    return new Error(&#x27;error!!!&#x27;)\n  })\n  .then((res) =&gt; {\n    console.log(&#x27;then: &#x27;, res)\n  })\n  .catch((err) =&gt; {\n    console.log(&#x27;catch: &#x27;, err)\n  })\n</code></pre><h3>题目七</h3>\n<pre class=\"prettyprint language-js\"><code>const promise = Promise.resolve()\n  .then(() =&gt; {\n    return promise\n  })\npromise.catch(console.error)\n</code></pre><h3>题目八</h3>\n<pre class=\"prettyprint language-js\"><code>Promise.resolve(1)\n  .then(2)\n  .then(Promise.resolve(3))\n  .then(console.log)\n</code></pre><h3>题目九</h3>\n<pre class=\"prettyprint language-js\"><code>Promise.resolve()\n  .then(function success (res) {\n    throw new Error(&#x27;error&#x27;)\n  }, function fail1 (e) {\n    console.error(&#x27;fail1: &#x27;, e)\n  })\n  .catch(function fail2 (e) {\n    console.error(&#x27;fail2: &#x27;, e)\n  })\n</code></pre><h3>题目十</h3>\n<pre class=\"prettyprint language-js\"><code>process.nextTick(() =&gt; {\n  console.log(&#x27;nextTick&#x27;)\n})\nPromise.resolve()\n  .then(() =&gt; {\n    console.log(&#x27;then&#x27;)\n  })\nsetImmediate(() =&gt; {\n  console.log(&#x27;setImmediate&#x27;)\n})\nconsole.log(&#x27;end&#x27;)\n</code></pre><h2>结果</h2>\n<p>执行结果及解释见我的知乎文章：<a href=\"https://zhuanlan.zhihu.com/p/30797777\">https://zhuanlan.zhihu.com/p/30797777</a></p>\n</div>","title":"Promise 必知必会（十道题）","last_reply_at":"2017-11-15T03:07:38.651Z","good":true,"top":false,"reply_count":15,"visit_count":1682,"create_at":"2017-11-07T06:03:42.337Z","author":{"loginname":"nswbmw","avatar_url":"https://avatars0.githubusercontent.com/u/4279697?v=4&s=120"}},{"id":"5a0aea66310be7561d4c0485","author_id":"59c1dcee8812ce51127a9026","tab":"share","content":"<div class=\"markdown-text\"><p>光使用 Node.js 自带的 cluster 模块做多进程应用是吃力的。</p>\n<p>SFN-Channel 提供了一个简洁友好的多进程通信 API，让你可以像类似 <a href=\"http://Socket.io\">Socket.io</a> 那样在工作进程和主进程、工作进程和工作进程之间，方便的传递数据。</p>\n<pre class=\"prettyprint\"><code>const Channel = require(&quot;sfn-channel&quot;);\nif (Channel.isMaster) {\n\t&#x2F;&#x2F; Master process\n\t&#x2F;&#x2F; Create two channels listens to worker processes A and B, and keep them \n\t&#x2F;&#x2F; alive.\n\tnew Channel(&quot;A&quot;, true);\n\tnew Channel(&quot;B&quot;, true);\n\n\t&#x2F;&#x2F; Do logics when the channel is online.\n\tChannel.on(&quot;online&quot;, (channel) =&gt; {\n    \tchannel.on(&quot;greeting from worker&quot;, (msg) =&gt; {\n        \tconsole.log(&quot;Worker %s: %s&quot;, channel.id, msg);\n        \t&#x2F;&#x2F; greet back\n        \tchannel.emit(&quot;greeting from master&quot;, &#96;Hello, worker ${channel.id}!&#96;);\n    \t});\n\t});\n} else {\n\t&#x2F;&#x2F; Worker process\n\tChannel.on(&quot;online&quot;, channel =&gt; {\n    \tchannel.emit(&quot;greeting from worker&quot;, &#96;Hi, master, I&#x27;m worker ${channel.id}!&#96;);\n\n    \tchannel.on(&quot;greeting from master&quot;, msg =&gt; {\n        \tconsole.log(&quot;Master: %s&quot;, msg);\n    \t}).on(&quot;greeting from another worker&quot;, (id, msg) =&gt; {\n        \tconsole.log(&quot;Worker %s: %s&quot;, id, msg);\n        \t&#x2F;&#x2F; greet back\n        \tchannel.to(id).emit(&quot;greeting back to another worker&quot;, channel.id, &#96;Nice to meet you, worker ${id}!&#96;);\n    \t}).on(&quot;greeting back to another worker&quot;, (id, msg) =&gt; {\n        \tconsole.log(&quot;Worker %s: %s&quot;, id, msg);\n    \t})\n\n    \tif (channel.id === &quot;A&quot;) {\n        \tchannel.to(&quot;B&quot;).emit(&quot;greeting from another worker&quot;, &quot;A&quot;, &#96;Hi, worker B, I&#x27;m worker A!&#96;);\n    \t}\n\t});\n}\n</code></pre><p>更多细节请访问 <a href=\"https://github.com/hyurl/sfn-channel\">GitHub</a> 页面。</p>\n</div>","title":"SFN-Channel 多进程和通信模块","last_reply_at":"2017-11-15T02:45:35.631Z","good":false,"top":false,"reply_count":2,"visit_count":129,"create_at":"2017-11-14T13:06:46.146Z","author":{"loginname":"Hyurl","avatar_url":"https://avatars1.githubusercontent.com/u/16103955?v=4&s=120"}},{"id":"5a0baa3b310be7561d4c0497","author_id":"59dad2572543cb3368b1626d","tab":"share","content":"<div class=\"markdown-text\"><p>另外一种方式去实现路由，管理项目更加方便。</p>\n<h2>优点</h2>\n<p>1.理更加清晰，一个类型的路由就是一个文件。</p>\n<p>2.所有的请求都经过一个公用的方法，处理方便。</p>\n<p>3.接口只有一个，不同的请求只有传入的参数不同。</p>\n<h2>使用</h2>\n<blockquote>\n<p>npm install router-plan</p>\n</blockquote>\n<h4>文件目录如下：</h4>\n<pre class=\"prettyprint\"><code>- router-list           ---存放路由的文件夹\n      - A               ---路由文件夹\n            - a.js      ---具体的路由文件    \n            - index.js  ---暴露当前路径下的所有的路由文件的方法\n      - index.js        ---暴露当前路径下的所有的路由文件\n- server.js\n</code></pre><h4>server.js文件格式如下，创建服务器成功之后，只需要调用routerPlan()这个方法并传入传入对应参数，其他的自动帮你实现。</h4>\n<pre class=\"prettyprint language- javascript\"><code>const http = require(&#x27;http&#x27;);\nconst routerPlan = require(&#x27;router-plan&#x27;);\nhttp.createServer((req,res) =&gt; {\n    routerPlan(req, res, {\n        routerList:require(&#x27;.&#x2F;router-list&#x27;),    &#x2F;&#x2F;路由文件地址\n        crossDomain:true                        &#x2F;&#x2F;是否允许跨域\n    });\n}).listen(80,() =&gt; {\n    console.log(&#x27;server start ok!&#x27;);\n});\n</code></pre><h4>router-list文件夹下面的index.js,主要用于暴露router-list文件夹里面的文件，用来生成json对象。</h4>\n<pre class=\"prettyprint language- javascript\"><code>const fileList = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;];&#x2F;&#x2F;router-list下面所有的文件夹名字\n\nfileList.forEach((fileName) =&gt; {\n    module.exports[fileName] = require(&#96;.&#x2F;${fileName}&#96;);\n});\n</code></pre><h4>A文件夹下面的index.js，主要用来暴露A文件夹里面所有的文件，用来生成json对象</h4>\n<pre class=\"prettyprint language- javascript\"><code>const fileList = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;];&#x2F;&#x2F;A下面所有的文件夹名字\n\nfileList.forEach((fileName) =&gt; {\n    module.exports[fileName] = require(&#96;.&#x2F;${fileName}&#96;);\n});\n</code></pre><h4>a.js文件格式如下：路由文件写法，把方法都暴露给对应的上层对象，通过exports.functionName(方法名字)来写接口。</h4>\n<pre class=\"prettyprint language- javascript\"><code>exports.a1 = function (query,req,res) {\n      res.end(&#x27;this is fileName:c,fn:a1&#x27;);\n};\n\nexports.a2 = function (query,req,res) {\n    res.end(&#x27;this is fileName:c,fn:a2&#x27;);\n};\n</code></pre><h4>客户端请求参数如下：</h4>\n<p>eg:请求A文件夹a里面的a1方法</p>\n<pre class=\"prettyprint\"><code>$.ajax({\n    url: &#x27;http:&#x2F;&#x2F;localhost&#x27;,\n    type:&#x27;post&#x27;,\n    data: {\n        folderName: &quot;A&quot;,     &#x2F;&#x2F;router-list文件夹下面的文件夹名字\n        fileName: &quot;a&quot;,       &#x2F;&#x2F;A文件夹下面的文件名字\n        fn: &quot;a1&quot;             &#x2F;&#x2F;a文件里面的方法名字\n    },\n    success: function (data) {\n        console.log(JSON.parse(data));\n    }\n})\n</code></pre><p>gitee地址：<a href>https://gitee.com/meetqy/router-plan/</a></p>\n<p>github地址：<a href>https://github.com/meetqy/router-plan/</a></p>\n</div>","title":"Node.js模块 router-plan","last_reply_at":"2017-11-15T02:45:15.046Z","good":false,"top":false,"reply_count":0,"visit_count":80,"create_at":"2017-11-15T02:45:15.046Z","author":{"loginname":"37372842","avatar_url":"https://avatars1.githubusercontent.com/u/18411315?v=4&s=120"}},{"id":"5a0ab09aef333d0e2e61a058","author_id":"59795c728f0313ff0d08d864","tab":"ask","content":"<div class=\"markdown-text\"><p>用户的登录日志、交易日志如果每个人都要保存一份，岂不是太多了\n错误日志、系统日志什么的如果随着时间的推移也会不少…\n求指点…</p>\n</div>","title":"服务器日志都输出些什么，保存在哪里。日志太多如何处理...","last_reply_at":"2017-11-15T01:04:24.049Z","good":false,"top":false,"reply_count":2,"visit_count":230,"create_at":"2017-11-14T09:00:10.243Z","author":{"loginname":"SunGg12138","avatar_url":"https://avatars0.githubusercontent.com/u/16427275?v=4&s=120"}},{"id":"5a0b8e06a57c17282e12067a","author_id":"5a0b14fd310be7561d4c048d","tab":"ask","content":"<div class=\"markdown-text\"><p>目前项目用webpack打包出来的前端会把各个组件都打进去。\n我想希望改造成前端通过webpack只发布一个壳子,并且各个组件是独立的,也是webpack发布的,然后壳子有一个插件管理或者叫组件管理的功能,可以上传webpack发布的组件并通过nodejs处理后动态显示上传上去的组件功能。\n就像WordPress的插件功能一样。请问应该怎么实现？react的ssr加上nodejs是否就能满足？谢谢！</p>\n</div>","title":"请问想用react做一个类似WordPress插件机制的功能应该怎么做？谢谢！","last_reply_at":"2017-11-15T00:44:54.177Z","good":false,"top":false,"reply_count":0,"visit_count":87,"create_at":"2017-11-15T00:44:54.177Z","author":{"loginname":"x22x22","avatar_url":"https://avatars2.githubusercontent.com/u/3389949?v=4&s=120"}},{"id":"5a0ac2d78eca04a009808ddb","author_id":"588097c7250bf4e2390e9df0","tab":"ask","content":"<div class=\"markdown-text\"><ol>\n<li>redis 应该不行</li>\n<li>通过MQ吗?</li>\n</ol>\n</div>","title":"websocket 服务器端 如何通信","last_reply_at":"2017-11-14T23:46:41.502Z","good":false,"top":false,"reply_count":1,"visit_count":205,"create_at":"2017-11-14T10:17:59.893Z","author":{"loginname":"yangchongduo","avatar_url":"https://avatars0.githubusercontent.com/u/19145102?v=4&s=120"}},{"id":"5a03f6a584ed7ceb219ea84e","author_id":"58f5cd11dcf05024569408fd","tab":"share","content":"<div class=\"markdown-text\"><p>先丢链接<br>\n<a href=\"https://github.com/flowfire/fffmwk\">https://github.com/flowfire/fffmwk</a></p>\n<p>最近入门 angular 和 node</p>\n<p>然后觉得那些 node 框架好麻烦我并不需要那么多功能。。。<br>\n所以就自己写了一个很简单的东西。。。</p>\n<p>大概功能就是<br>\n启动一个 nodejs server<br>\n把 api 请求传递给 api 模块解析<br>\n把静态文件请求传递给静态文件<br>\n然后把剩余所有请求全部重定向到主文件，把路由交给前端处理。</p>\n<p><em>(:з)∠)</em><br>\n一个很简单的小项目，坐等大佬们指点。（乖巧.png）<br>\n<img src=\"//dn-cnode.qbox.me/FnbYJoWS-3y16qihjPKZLzija305\" alt=\"oNBEw32M.jpg\"></p>\n</div>","title":"昨天写了一个超级简单的单页面应用的 node js server","last_reply_at":"2017-11-14T17:59:20.889Z","good":false,"top":false,"reply_count":2,"visit_count":461,"create_at":"2017-11-09T06:33:09.526Z","author":{"loginname":"flowfire","avatar_url":"https://avatars0.githubusercontent.com/u/6639067?v=4&s=120"}},{"id":"5a0a9c5adea908392cfc8936","author_id":"541b8a5a73bd33af05384b8f","tab":"ask","content":"<div class=\"markdown-text\"><p>如题，本人不是研究算法的，不太了解加密算法之类的，找了一下github也没找到合适的，来此请教一下各位</p>\n</div>","title":"有人做过国密sm4算法js的实现的么?","last_reply_at":"2017-11-14T16:04:10.673Z","good":false,"top":false,"reply_count":5,"visit_count":274,"create_at":"2017-11-14T07:33:46.502Z","author":{"loginname":"panhb","avatar_url":"https://avatars2.githubusercontent.com/u/8011065?v=4&s=120"}},{"id":"548e54d157fd3ae46b233502","author_id":"54704fc4a3e2aee40698dde9","tab":"share","content":"<div class=\"markdown-text\"><h1>Mongoose 参考手册</h1>\n<p>标签（空格分隔）： MongoDB</p>\n<hr>\n<h2>Mongoose 是什么?</h2>\n<p>一般我们不直接用MongoDB的函数来操作MongoDB数据库 Mongose就是一套操作MongoDB数据库的接口.</p>\n<h4><strong>Schema</strong></h4>\n<p>一种以文件形式存储的数据库模型骨架，无法直接通往数据库端，也就是说它不具备对数据库的操作能力.可以说是数据属性模型(传统意义的表结构)，又或着是“集合”的模型骨架</p>\n<pre class=\"prettyprint\"><code>&#x2F;* 定义一个 Schema *&#x2F;\nvar mongoose = require(&quot;mongoose&quot;);\n\nvar TestSchema = new mongoose.Schema({\n    name : { type:String },&#x2F;&#x2F;属性name,类型为String\n    age  : { type:Number, default:0 },&#x2F;&#x2F;属性age,类型为Number,默认为0\n    time : { type:Date, default:Date.now },\n    email: { type:String,default:&#x27;&#x27;}\n});\n</code></pre><p>上面这个 TestSchema包含4个属性 [name, age, time, email]</p>\n<h4><strong>Model</strong></h4>\n<p>由Schema构造生成的模型，除了Schema定义的数据库骨架以外，还具有数据库操作的行为，类似于管理数据库属性、行为的类</p>\n<pre class=\"prettyprint\"><code>var db = mongoose.connect(&quot;mongodb:&#x2F;&#x2F;127.0.0.1:27017&#x2F;test&quot;);\n\n&#x2F;&#x2F; 创建Model\nvar TestModel = db.model(&quot;test1&quot;, TestSchema);\n</code></pre><p>test1 数据库中的集合名称, 不存在会创建.</p>\n<h4><strong>Entity</strong></h4>\n<p>由Model创建的实体，使用save方法保存数据，Model和Entity都有能影响数据库的操作，但Model比Entity更具操作性</p>\n<pre class=\"prettyprint\"><code>var TestEntity = new TestModel({\n       name : &quot;Lenka&quot;,\n       age  : 36,\n       email: &quot;lenka@qq.com&quot;\n});\nconsole.log(TestEntity.name); &#x2F;&#x2F; Lenka\nconsole.log(TestEntity.age); &#x2F;&#x2F; 36\n</code></pre><h4><strong>游标</strong></h4>\n<p>MongoDB 使用游标返回find的执行结果.客户端对游标的实现通常能够对最终结果进行有效的控制。可以限制结果的数量，略过部分结果，根据任意键按任意顺序的组合对结果进行各种排序，或者是执行其他一些强的操作。</p>\n<h4><strong>ObjectId</strong></h4>\n<p>存储在mongodb集合中的每个文档（document）都有一个默认的主键_id，这个主键名称是固定的，它可以是mongodb支持的任何数据类型，默认是ObjectId。</p>\n<p>ObjectId是一个12字节的 BSON 类型字符串。按照字节顺序，依次代表：\n4字节：UNIX时间戳\n3字节：表示运行MongoDB的机器\n2字节：表示生成此_id的进程\n3字节：由一个随机数开始的计数器生成的值</p>\n<h4><strong>Node.js 中</strong></h4>\n<p>package.json 中加入&quot;mongoose&quot;: “*” 字段\nnpm install 安装依赖.</p>\n<pre class=\"prettyprint\"><code>var mongoose = require(&quot;mongoose&quot;);\nvar db = mongoose.connect(&quot;mongodb:&#x2F;&#x2F;localhost:27017&#x2F;test&quot;);\n</code></pre><p>然后引用</p>\n<h2><strong>API</strong></h2>\n<pre class=\"prettyprint\"><code>var mongoose = require(&quot;mongoose&quot;);\nvar db = mongoose.connect(&quot;mongodb:&#x2F;&#x2F;localhost:27017&#x2F;test&quot;);\n</code></pre><h3>db - 数据库操作</h3>\n<p>1.挂接数据库连接事件,参数1: 也可以是error.</p>\n<blockquote>\n<p>db.connection.on(‘open’, callback);</p>\n</blockquote>\n<h3>Schema - 表结构</h3>\n<p>1.构造函数</p>\n<blockquote>\n<p>new mongoose.Schema( { name:{type:String}, age:{type:Number, default:10}  } )</p>\n</blockquote>\n<p>2.添加属性</p>\n<blockquote>\n<p>Schema.add( { name: ‘String’, email: ‘String’, age: ‘Number’ } )</p>\n</blockquote>\n<p>3.有时候Schema不仅要为后面的Model和Entity提供公共的属性，还要提供公共的方法</p>\n<blockquote>\n<p>Schema.method( ‘say’, function(){console.log(‘hello’);} )\n//这样Model和Entity的实例就能使用这个方法了</p>\n</blockquote>\n<p>4.添加静态方法</p>\n<blockquote>\n<p>Schema.static( ‘say’, function(){console.log(‘hello’);} )\n//静态方法，只限于在Model层就能使用</p>\n</blockquote>\n<p>5.追加方法</p>\n<blockquote>\n<p>Schema.methods.say = function(){console.log(‘hello’);};\n//静态方法，只限于在Model层就能使用</p>\n</blockquote>\n<h3>model - 文档操作</h3>\n<p>1.构造函数, 参数1:集合名称, 参数2:Schema实例</p>\n<blockquote>\n<p>db.model(“test1”, TestSchema );</p>\n</blockquote>\n<p>2.查询, 参数1忽略,或为空对象则返回所有集合文档</p>\n<blockquote>\n<p>model.find({}, callback);</p>\n</blockquote>\n<blockquote>\n<p>model.find({},field,callback);\n过滤查询,参数2: {‘name’:1, ‘age’:0} 查询文档的返回结果包含name , 不包含age.(_id默认是1)</p>\n</blockquote>\n<blockquote>\n<p>model.find({},null,{limit:20});\n过滤查询,参数3: 游标操作 limit限制返回结果数量为20个,如不足20个则返回所有.</p>\n</blockquote>\n<blockquote>\n<p>model.findOne({}, callback);\n查询找到的第一个文档</p>\n</blockquote>\n<blockquote>\n<p>model.findById(‘obj._id’, callback);\n查询找到的第一个文档,同上. 但是只接受 __id 的值查询</p>\n</blockquote>\n<p>3.创建, 在集合中创建一个文档</p>\n<blockquote>\n<p>Model.create(文档数据, callback))</p>\n</blockquote>\n<p>4.更新,参数1:查询条件, 参数2:更新对象,可以使用MondoDB的更新修改器</p>\n<blockquote>\n<p>Model.update(conditions, update, function(error)</p>\n</blockquote>\n<p>5.删除, 参数1:查询条件</p>\n<blockquote>\n<p>Model.remove(conditions,callback);</p>\n</blockquote>\n<h3>Entity - 文档操作</h3>\n<p>1.构造函数, 其实就是model的实例</p>\n<blockquote>\n<p>new TestModel( { name:‘xueyou’, age:21 } );</p>\n</blockquote>\n<p>2.创建, 在集合中创建一个文档.</p>\n<blockquote>\n<p>Entity.save(callback);</p>\n</blockquote>\n<h2>修改器和更新器</h2>\n<h4><strong>更新修改器:</strong></h4>\n<p>‘$inc’ 增减修改器,只对数字有效.下面的实例: 找到 age=22的文档,修改文档的age值自增1</p>\n<blockquote>\n<p>Model.update({‘age’:22}, {’$inc’:{‘age’:1} }  );\n执行后: age=23</p>\n</blockquote>\n<p>‘$set’ 指定一个键的值,这个键不存在就创建它.可以是任何MondoDB支持的类型.</p>\n<blockquote>\n<p>Model.update({‘age’:22}, {’$set’:{‘age’:‘haha’} }  );\n执行后: age=‘haha’</p>\n</blockquote>\n<p>‘$unset’ 同上取反,删除一个键</p>\n<blockquote>\n<p>Model.update({‘age’:22}, {’$unset’:{‘age’:‘haha’} }  );\n执行后: age键不存在</p>\n</blockquote>\n<h4><strong>数组修改器:</strong></h4>\n<p>‘$push’ 给一个键push一个数组成员,键不存在会创建</p>\n<blockquote>\n<p>Model.update({‘age’:22}, {’$push’:{‘array’:10} }  );\n执行后: 增加一个 array 键,类型为数组, 有一个成员 10</p>\n</blockquote>\n<p>‘$addToSet’ 向数组中添加一个元素,如果存在就不添加</p>\n<blockquote>\n<p>Model.update({‘age’:22}, {’$addToSet’:{‘array’:10} }  );\n执行后: array中有10所以不会添加</p>\n</blockquote>\n<p>‘$each’ 遍历数组, 和 $push 修改器配合可以插入多个值</p>\n<blockquote>\n<p>Model.update({‘age’:22}, {’$push’:{‘array’:{’$each’: [1,2,3,4,5]}} }  );\n执行后: array : [10,1,2,3,4,5]</p>\n</blockquote>\n<p>‘$pop’ 向数组中尾部删除一个元素</p>\n<blockquote>\n<p>Model.update({‘age’:22}, {’$pop’:{‘array’:1} }  );\n执行后: array : [10,1,2,3,4]  tips: 将1改成-1可以删除数组首部元素</p>\n</blockquote>\n<p>‘$pull’ 向数组中删除指定元素</p>\n<blockquote>\n<p>Model.update({‘age’:22}, {’$pull’:{‘array’:10} }  );\n执行后: array : [1,2,3,4]  匹配到array中的10后将其删除</p>\n</blockquote>\n<h4><strong>条件查询:</strong></h4>\n<ul>\n<li>“$lt”\t小于</li>\n<li>“$lte”\t小于等于</li>\n<li>“$gt”\t大于</li>\n<li>“$gte”\t大于等于</li>\n<li>“$ne”\t不等于</li>\n</ul>\n<blockquote>\n<p>Model.find({“age”:{ “$get”:18 , “$lte”:30 } } );\n查询 age 大于等于18并小于等于30的文档</p>\n</blockquote>\n<h4><strong>或查询 OR:</strong></h4>\n<ul>\n<li>‘$in’    一个键对应多个值</li>\n<li>‘$nin’   同上取反,  一个键不对应指定值</li>\n<li>“$or”    多个条件匹配, 可以嵌套 $in 使用</li>\n<li>“$not”\t同上取反, 查询与特定模式不匹配的文档</li>\n</ul>\n<blockquote>\n<p>Model.find({“age”:{ “$in”:[20,21,22.‘haha’]} } );\n查询 age等于20或21或21或’haha’的文档</p>\n</blockquote>\n<blockquote>\n<p>Model.find({&quot;$or&quot; :  [ {‘age’:18} , {‘name’:‘xueyou’} ] });\n查询 age等于18 或 name等于’xueyou’ 的文档</p>\n</blockquote>\n<h4><strong>类型查询:</strong></h4>\n<p>null 能匹配自身和不存在的值, 想要匹配键的值 为null, 就要通过  “$exists” 条件判定键值已经存在\n&quot;$exists&quot; (表示是否存在的意思)</p>\n<blockquote>\n<p>Model.find(“age” :  { “$in” : [null] , “exists” : true  } );\n查询 age值为null的文档</p>\n</blockquote>\n<pre class=\"prettyprint\"><code>Model.find({name: {$exists: true}},function(error,docs){\n  &#x2F;&#x2F;查询所有存在name属性的文档\n});\n\nModel.find({telephone: {$exists: false}},function(error,docs){\n  &#x2F;&#x2F;查询所有不存在telephone属性的文档\n});\n</code></pre><h4><strong>正则表达式:</strong></h4>\n<p>MongoDb 使用 Prel兼容的正则表达式库来匹配正则表达式</p>\n<blockquote>\n<p>find( {“name” : /joe/i } )\t\n查询name为 joe 的文档, 并忽略大小写</p>\n</blockquote>\n<blockquote>\n<p>find( {“name” : /joe?/i } )\n查询匹配各种大小写组合</p>\n</blockquote>\n<h4><strong>查询数组:</strong></h4>\n<blockquote>\n<p>Model.find({“array”:10} );\n查询 array(数组类型)键中有10的文档,  array : [1,2,3,4,5,10]  会匹配到</p>\n</blockquote>\n<blockquote>\n<p>Model.find({“array[5]”:10} );\n查询 array(数组类型)键中下标5对应的值是10,  array : [1,2,3,4,5,10]  会匹配到</p>\n</blockquote>\n<p>‘$all’ 匹配数组中多个元素</p>\n<blockquote>\n<p>Model.find({“array”:[5,10]} );\n查询 匹配array数组中 既有5又有10的文档</p>\n</blockquote>\n<p>‘$size’ 匹配数组长度</p>\n<blockquote>\n<p>Model.find({“array”:{&quot;$size&quot; : 3} } );\n查询 匹配array数组长度为3 的文档</p>\n</blockquote>\n<p>‘$slice’ 查询子集合返回</p>\n<blockquote>\n<p>Model.find({“array”:{&quot;$skice&quot; : 10} } );\n查询 匹配array数组的前10个元素</p>\n</blockquote>\n<blockquote>\n<p>Model.find({“array”:{&quot;$skice&quot; : [5,10] } } );\n查询 匹配array数组的第5个到第10个元素</p>\n</blockquote>\n<h4><strong>where</strong></h4>\n<p>用它可以执行任意javacript语句作为查询的一部分,如果回调函数返回 true 文档就作为结果的一部分返回</p>\n<pre class=\"prettyprint\"><code>\tfind( {&quot;$where&quot; : function(){\n\t\tfor( var x in this ){\n\t\t &#x2F;&#x2F;这个函数中的 this 就是文档\n\t\t}\n\t\t\n\t\tif(this.x !== null &amp;&amp; this.y !== null){\n\t\t    return this.x + this.y === 10 ? true : false;\n\t\t}else{\n\t\t    return true;\n\t\t}\n\t\t\n\t\t\n}  }  )\n</code></pre><p>简化版本</p>\n<pre class=\"prettyprint\"><code>\tfind( {&quot;$where&quot; :  &quot;this.x + this.y === 10&quot; } )\n\tfind( {&quot;$where&quot; : &quot; function(){ return this.x + this.y ===10; } &quot; } )\n</code></pre><h4><strong>游标:</strong></h4>\n<ul>\n<li>limit(3)\t限制返回结果的数量,</li>\n<li>skip(3)\t    跳过前3个文档,返回其余的</li>\n<li>sort( {“username”:1 , “age”:-1 } )\t    排序 键对应文档的键名, 值代表排序方向, 1 升序, -1降序</li>\n</ul>\n</div>","title":"Node.js 手册查询-3-Mongoose 方法","last_reply_at":"2017-11-14T15:52:55.161Z","good":true,"top":false,"reply_count":21,"visit_count":48736,"create_at":"2014-12-15T03:26:09.566Z","author":{"loginname":"xueyou2000","avatar_url":"https://avatars0.githubusercontent.com/u/8541279?v=4&s=120"}},{"id":"533d6edbc2621e680800e0ea","author_id":"525e55c4d0af751c0e5e034a","content":"<div class=\"markdown-text\"><p>###【本文是基础内容，大神请绕道，才疏学浅，难免纰漏，请各位轻喷】\n##1.\t概述\n目前开源社区最火热的技术当属Node.js莫属了，作为使用Javascript为主要开发语言的服务器端编程技术和平台，一开始就注定会引人瞩目。 当然能够吸引众人的目光，肯定不是三教九流之辈，必然拥有独特的优势和魅力，才能引起群猿追逐。其中当属异步IO和事件编程模型，本文据Node.js的异步IO和事件编程做深入分析。\n##2.\t什么是异步\n同步和异步是一个比较早的概念，大抵在操作系统发明时应该就出现了。举一个最简单的生活中的例子，比如发短信的情况会比较好说明他们的区别：\n同步：正在处于苦逼工作状态中的我，但狗屎运的交到了女朋友并正处于处于热恋期，因此发送短信给她询问那个餐厅吃饭，急不可耐的看着手机等待短信回复，收到信息看完是否加班或者下班；\n异步：正处于公司运营决策关键工作状态中的你，不可以被打断太久，随便发送了一条询问老婆什么时候做好晚饭然后吃饭的短信后立马返回工作，一边工作一边等待短信回复通知，根据通知决定是否再工作和下班。\n由此可以看出，同步和异步的特点是：</p>\n<ol>\n<li>至少在两个对象之间需要协作（男朋友和女朋友，老公和老婆）；</li>\n<li>两个对象都需要处理一系列的事情（工作和吃饭）。\n另一个类似的关于CPU计算和磁盘操作编的例子：\n同步：CPU需要计算10个数据，每计算一个结果后，将其写入磁盘，等待写入成功后，再计算下一个数据，直到完成。\n异步：CPU需要计算10个数据，每计算一个结果后，将其写入磁盘，不等待写入成功与否的结果，立刻返回继续计算下一个数据，计算过程中可以收到之前写入是否成功的通知，直到完成。</li>\n</ol>\n<p>##3.\t为什么需要异步\n知其然，还要知其所以然，读者可能会问，为什么存在异步？根据上面发短信和磁盘操作的例子，答案很明显，为了提高办事的效率，CPU计算速度和磁盘的读写速度差太远了，磁盘供不应求，因此有了计算机的存储系统的分层设计，平衡了效率和成本。可以说懒惰推动人类的进步，任何可以降低花费时间而达到同等功效的方法肯定会被优先采用。发送短信时等待对方回复的时间纯粹的浪费掉了，CPU写入磁盘等待返回的结果的等待时间也被无情的消耗了，这是一个讲究效率的时代完全不能忍受的，因此让员工一直处于忙碌状态，最大限度的榨取员工价值是老板追求的，让CPU和磁盘都不停的满负荷处理事务也是效率需要的。因此，异步处理出现了。</p>\n<p>##4.\tNode.js异步IO与事件\n初次接触Node.js，恐怕任何人都会被先先灌输的第一条Node.js就与众不同的地方：异步IO和事件驱动。毫无疑问，这确实是Node.js最令人津津乐道的特色之处，也是本文重点分析的地方。\n###4.1\tNode.js异步机制\n由于异步的高效性，node.js设计之初就考虑做为一个高效的web服务器，作者理所当然地使用了异步机制，并贯穿于整个node.js的编程模型中，新手在使用node.js编程时，往往会羁绊于由于其他编程语言的习惯，比如C/C++，觉得无所适从。我们可以从以下一段简单的睡眠程序代码窥视出他们的区别，下面是摘自《linux程序设计》打印10个时间的C代码：</p>\n<pre class=\"prettyprint\"><code>#include &lt;time.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\nint main()\n{\n    int i;\n    time_t the_time;\n    for(i = 1; i &lt;= 10; i++) {\n        the_time = time((time_t *)0);\n        printf(&quot;The time is %ld\\n&quot;, the_time);\n        sleep(2);\n    }\n    exit(0);\n}\n</code></pre><p>编译后打印结果如下：\nThe time is 1396492137\nThe time is 1396492139\nThe time is 1396492141\nThe time is 1396492143\nThe time is 1396492145\nThe time is 1396492147\nThe time is 1396492149\nThe time is 1396492151\nThe time is 1396492153\nThe time is 1396492155\n从C语言的打印结果可以发现，是隔2秒打印一次，按照C程序该有的逻辑，代码逐行执行。以下Node.js代码本意如同上述C代码，使用目的隔2秒打印一次时间，共打印10条（初次从C/C++转来接触Node.js的程序员可能会写出下面的代码）：</p>\n<pre class=\"prettyprint\"><code>function test() {\n    for (var i = 0; i &lt; 10; i++) {\n        console.log(new Date);\n        setTimeout(function(){}, 2000);\t&#x2F;&#x2F;睡眠2秒，然后再进行一下次for循环打印\n    }\n};\ntest();\n</code></pre><p>打印结果：\nTue Apr 01 2014 14:53:22 GMT+0800 (中国标准时间)<br>\nTue Apr 01 2014 14:53:22 GMT+0800 (中国标准时间)<br>\nTue Apr 01 2014 14:53:22 GMT+0800 (中国标准时间)<br>\nTue Apr 01 2014 14:53:22 GMT+0800 (中国标准时间)<br>\nTue Apr 01 2014 14:53:22 GMT+0800 (中国标准时间)<br>\nTue Apr 01 2014 14:53:22 GMT+0800 (中国标准时间)<br>\nTue Apr 01 2014 14:53:22 GMT+0800 (中国标准时间)<br>\nTue Apr 01 2014 14:53:22 GMT+0800 (中国标准时间)<br>\nTue Apr 01 2014 14:53:22 GMT+0800 (中国标准时间)<br>\nTue Apr 01 2014 14:53:22 GMT+0800 (中国标准时间)<br>\n观察结果发现都是在14:53:22同一个时间点打印的，根本就没有睡眠2秒后再执行下一轮循环打印！这是为什么？从官方的文档我们看出setTimeout是第二个参数表示逝去时间之后在执行第一个参数表示的callback函数，因此我们可以分析， 由于Node.js的异步机制，setTimeout每个for循环到此之后，都注册了一个2秒后执行的回调函数然后立即返回马上执行console.log(new Date)，导致了所有打印的时间都是同一个点，因此我们修改for循环的代码如下：</p>\n<pre class=\"prettyprint\"><code>for (var i = 0; i &lt; 10; i++) {\nsetTimeout(function(){\nconsole.log(new Date);\n}, 2000);\t\n\n}\n</code></pre><p>执行结果如下所示：\nThu Apr 03 2014 09:30:35 GMT+0800 (中国标准时间)<br>\nThu Apr 03 2014 09:30:35 GMT+0800 (中国标准时间)<br>\nThu Apr 03 2014 09:30:35 GMT+0800 (中国标准时间)<br>\nThu Apr 03 2014 09:30:35 GMT+0800 (中国标准时间)<br>\nThu Apr 03 2014 09:30:35 GMT+0800 (中国标准时间)<br>\nThu Apr 03 2014 09:30:35 GMT+0800 (中国标准时间)<br>\nThu Apr 03 2014 09:30:35 GMT+0800 (中国标准时间)<br>\nThu Apr 03 2014 09:30:35 GMT+0800 (中国标准时间)<br>\nThu Apr 03 2014 09:30:35 GMT+0800 (中国标准时间)<br>\nThu Apr 03 2014 09:30:35 GMT+0800 (中国标准时间)\n神奇，仍然是同一个时间点，见鬼！冷静下来分析，时刻考虑异步，for循环里每次setTimeout注册了2秒之后执行的一个打印时间的回调函数，然后立即返回，再执行setTimeout，如此反复直到for循环结束，因为执行速度太快，导致同一个时间点注册了10个2秒后执行的回调函数，因此导致了2秒后所有回调函数的立即执行。 我们在for循环之前添加console.log(&quot;before FOR: &quot; + new Date)和之后console.log(&quot;after FOR: &quot; + new Date)，来验证我们的推测，打印结果如下（后面省略8条相同的打印行）：\nbefore FOR: Thu Apr 03 2014 09:42:43 GMT+0800 (中国标准时间)<br>\nafter FOR: Thu Apr 03 2014 09:42:43 GMT+0800 (中国标准时间)<br>\nThu Apr 03 2014 09:42:45 GMT+0800 (中国标准时间)<br>\nThu Apr 03 2014 09:42:45 GMT+0800 (中国标准时间)\n……  （省略与上一行8条相同的打印行）\n由此可以窥视出Node.js异步机制的端倪了，在for循环中的代码于其后的代码几乎在一个单位秒内完成，而定时器中的回调函数则按要求的2秒之后执行，也是同一秒内执行完毕。那么如何实现最初C语言每隔2秒打印一个系统时间的需求函数呢，我实现了如下一个wsleep函数，放在for循环中，可以达到该目的：</p>\n<pre class=\"prettyprint\"><code>function wsleep(milliSecond) {\n    var startTime = new Date().getTime();\n    while(new Date().getTime() &lt;= milliSecond + startTime) {\n    }\n}\n</code></pre><p>但是该函数有一个令他无法在项目中使用的缺陷，请问为什么？\n###4.2\tNode.js事件编程\n事件编程并不是一个新的概念，做过界面UI编程的程序猿们可以觉得事件再熟悉不过了，特别是客户端开发和web开发的感触颇深吧，如Android、ios、或是javascript前端编程的工程师们，一个按钮、一个列表项、一个长按操作等等，每次按下都会由操作系统或者浏览器产生一个事件，你需要做的工作就是编写和注册这个事件的回调函数（可能各自领域内不称为回调函数，但是从操作系统的角度考虑其实就是一个回调函数），当这个事件发生时，执行你的回调函数。Node.js与众不同的时，它基因里就是由事件和异步组成的。请看用于生产环境中的真实项目代码的一个片段（略去了一些不相关的代码），我加上一段关于事件信息的注释，让读者更清晰：</p>\n<pre class=\"prettyprint\"><code>    self.sio.sockets.on(&#x27;connection&#x27;, function(socket) {\t\t&#x2F;&#x2F;监听socket连接事件\n        var addr = socket.handshake.address;\n        var limiter = new RateLimiter(constant.RL_MAXREQRATELIMIT, constant.RL_RATELIMITUNIT, true);\n        var connect = new Connection(socket);\n        then(function(defer) {\t\n            if (ipLimit) {\n                throttle.throttleHandle(connect, null, defer);\t&#x2F;&#x2F;结果回调处理事件\n            } else {\n                defer(null);\t&#x2F;&#x2F;发送处理结果事件\n            }\n        }).all(function(defer) {\t&#x2F;&#x2F;收到处理结果事件\n            socket.on(&#x27;message&#x27;, function(data) {\t&#x2F;&#x2F;监听数据传输事件\n     \t\t\tcloudKeyMain(connect, 1, data, cloudKeyApi);\n            });\n        });\n        socket.on(&quot;disconnect&quot;, function(data) {\t&#x2F;&#x2F;监听socket离线事件\n            var currentSockClient = connect.client;\n            if (currentSockClient) {\n                currentSockClient.signalOffline();\t&#x2F;&#x2F;发送客户端离线事件\n            }\n\n        });\n    });\n</code></pre><p>从上面的代码，我们可以看出Node.js无所不在的事件机制，事件机制让我们专注与代码业务的处理流程，提高了软件开发的效率，降低了代码之间的耦合，让人不被琐事缠绕，编程更有趣。如何开始一个简单的Node.js事件编程呢，答案是使用Node.js的javascript API核心模块events的events.EventEmitter类即可完成，下面以一个QQ的在线和离线来说明，\n事件机制的使用主要包括3个方面的内容：</p>\n<ol>\n<li>继承events.EventEmitter事件类，主要是屏蔽事件机制的实现（其实原理很简单），让我们直接使用；</li>\n<li>事件的注册；</li>\n<li>事件的发布。</li>\n</ol>\n<pre class=\"prettyprint\"><code>var events = require(&#x27;events&#x27;);\nvar util = require(&#x27;util&#x27;);\nfunction MyQQ() {\nevents.EventEmitter.call(this);\n&#x2F;&#x2F;……\n}\nutil.inherits(MyQQ, events.EventEmitter);\n</code></pre><p>OK，上述代码就完成了事件机制的添加，此时，我们的工作为QQ添加事件注册函数进行事件的注册，事件注册主要是使用EventEmitter的on()完成，因为我们继承了EventEmitter，可以直接使用on函数，我们在on函数的第二个参数callback函数中自定义处理业务，并注册自己的上线事件，以下是一个QQ上线时简单的处理业务：</p>\n<pre class=\"prettyprint\"><code>function onlineHandle(QQNumber) {\n\t&#x2F;&#x2F;获取和QQNumber的联系人列表\n\t&#x2F;&#x2F;获取离线消息\n\t&#x2F;&#x2F;……\n}\nvar myQQ = new MyQQ();\nmyQQ.on(“onLine”, onlineHandle);\n</code></pre><p>上述代码完成了事件的处理，下面轮到在什么时候发布这个事件，下述的一个业务场景中可能是需要发布该事件的，发布事件用emit()函数：</p>\n<pre class=\"prettyprint\"><code>function main() {\n\t&#x2F;&#x2F;连接服务器\n\t&#x2F;&#x2F;检测登录状态\n\t&#x2F;&#x2F;登录服务器成功后发布事件\n\tmyQQ.emit(“onLine”,123655245);\n}\n</code></pre><p>上述myQQ.emit()函数执行后发布了onLine事件后，会立即执行onlineHandle()函数，处理我们注册的业务逻辑，需要注意的是，事件发布函数emit第二个参数后的参数个数需要和我们注册时的处理函数参数个数相同并且顺序一致才能正确处理，为什么有这样的要求？这需要从Node.js事件的原理说起。基本上所有的事件机制都是用设计模式中观察者模式实现，观察着模式网络资料一大堆，如何想要深入了解的话可以网络搜索或者阅读权威书籍，可以参考《设计模式：可复用面向对象软件的基础》和《Head First设计模式》。</p>\n</div>","title":"深入理解node.js异步编程：基础篇","last_reply_at":"2017-11-14T14:51:04.972Z","good":true,"top":false,"reply_count":13,"visit_count":38352,"create_at":"2014-04-03T14:23:23.421Z","author":{"loginname":"melote","avatar_url":"//gravatar.com/avatar/98aab0827aad9d1d51d06591bf8ab9fb?size=48"}},{"id":"5a090a20001f0eb571c1b046","author_id":"57bb18956b04813133ba909b","tab":"share","content":"<div class=\"markdown-text\"><p>图片拖一拖，上传加压缩\nDemo网站：<a href=\"http://upload.andylistudio.com\">http://upload.andylistudio.com</a>\n源码地址：<a href=\"https://github.com/Andyliwr/ldk-upload-img\">https://github.com/Andyliwr/ldk-upload-img</a>\n截图：\n<img src=\"http://fs.andylistudio.com/source/img/slide1.png\" alt></p>\n<p><img src=\"http://fs.andylistudio.com/source/img/slide2.png\" alt></p>\n<p><img src=\"http://fs.andylistudio.com/source/img/slide3.png\" alt></p>\n</div>","title":"基于koa2实现的图片上传工具","last_reply_at":"2017-11-14T13:20:29.401Z","good":false,"top":false,"reply_count":1,"visit_count":265,"create_at":"2017-11-13T02:57:36.521Z","author":{"loginname":"Andyliwr","avatar_url":"https://avatars1.githubusercontent.com/u/12456160?v=4&s=120"}},{"id":"5a0a5e0bdea908392cfc892a","author_id":"5a0a5c9da57c17282e120654","tab":"share","content":"<div class=\"markdown-text\"><p>最近在研究koa和mongodb，简单做了个博客系统，目前还未开放评论和发帖功能，欢迎大家吐槽~</p>\n<h3>📦安装</h3>\n<pre class=\"prettyprint\"><code>git clone https:&#x2F;&#x2F;github.com&#x2F;oliyg&#x2F;alljscc.git\nnpm install\n</code></pre><h3>🎯启动</h3>\n<pre class=\"prettyprint\"><code>cd server\nnode app.js\n</code></pre><h3>📍DEMO地址</h3>\n<p><a href=\"http://alljs.cc\">alljs</a></p>\n<p><a href=\"http://alljs.cc\">http://alljs.cc</a></p>\n<h3>🍭功能</h3>\n<ul>\n<li>用户登录</li>\n<li>发布文章</li>\n<li>读取文章列表</li>\n<li>阅读文章</li>\n<li>搜索文章</li>\n</ul>\n<h3>🚥暂未开放功能</h3>\n<ul>\n<li>用户注册</li>\n<li>读取所有文章api</li>\n<li>修改文章</li>\n<li>删除文章</li>\n<li>全文搜索</li>\n</ul>\n<h3>🚨数据库参数</h3>\n<p>dbconfig.js</p>\n<blockquote>\n<p>guest用户用于数据库普通读取操作</p>\n</blockquote>\n<pre class=\"prettyprint language-js\"><code>module.exports = {\n    &#x2F;&#x2F; 数据库相关\n    db: {\n        name: &#x27;&#x27;, &#x2F;&#x2F;数据库名称\n        prot: &#x27;27017&#x27; &#x2F;&#x2F;端口，默认27017\n    },\n    &#x2F;&#x2F; 数据库只读用户guest\n    guest: {\n        name: &#x27;&#x27;, &#x2F;&#x2F;用户名\n        pw: &#x27;&#x27; &#x2F;&#x2F;密码\n    },\n    &#x2F;&#x2F; 数据库读写用户readWrite\n    readWrite: {\n        name: &#x27;&#x27;,\n        pw: &#x27;&#x27;\n    },\n    &#x2F;&#x2F; 网站登录用户\n    root: {\n        name: &#x27;&#x27;,\n        pw: &#x27;&#x27;\n    },\n    &#x2F;&#x2F; private key\n    tokenKey: &#x27;&#x27;\n};\n</code></pre></div>","title":"用koa mongodb 做了个简单的博客系统","last_reply_at":"2017-11-14T12:12:09.950Z","good":false,"top":false,"reply_count":2,"visit_count":263,"create_at":"2017-11-14T03:07:55.095Z","author":{"loginname":"oliyg","avatar_url":"https://avatars1.githubusercontent.com/u/19631785?v=4&s=120"}},{"id":"5a044c113b2c1f8108a45e7e","author_id":"56fdcb26c5f5b4a959e91751","tab":"share","content":"<div class=\"markdown-text\"><p>这几天终于在空余时间把我pc网站的<a href=\"https://www.geekjc.com\">极客教程</a>做了一个简洁的移动web，做得比较简单，看看效果图:<img src=\"http://upload-images.jianshu.io/upload_images/1637794-7436f6e26170e083.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>,暂时只有看文章的功能，其余的慢慢的再加。做这个的目的主要是想学习下react相关技术栈的更新。</p>\n<p>移动端地址: <a href=\"http://m.geekjc.com\">极客教程</a></p>\n</div>","title":"react,react-router 4,mobx构建我的移动端web","last_reply_at":"2017-11-14T11:11:45.162Z","good":false,"top":false,"reply_count":3,"visit_count":403,"create_at":"2017-11-09T12:37:37.332Z","author":{"loginname":"cllgeek","avatar_url":"https://avatars0.githubusercontent.com/u/15187909?v=4&s=120"}},{"id":"5a0abda38eca04a009808dd7","author_id":"5a0abd67a57c17282e12066a","tab":"ask","content":"<div class=\"markdown-text\"><p>请问，\nvar readable = getReadableStreamSomehow();\n怎么报错</p>\n</div>","title":"ReferenceError: getReadableStreamSomehow is not defined","last_reply_at":"2017-11-14T09:55:47.720Z","good":false,"top":false,"reply_count":0,"visit_count":127,"create_at":"2017-11-14T09:55:47.720Z","author":{"loginname":"caojiqian","avatar_url":"https://avatars1.githubusercontent.com/u/17639955?v=4&s=120"}},{"id":"5a051c74ee9b35da75a869f8","author_id":"56ebae5df8b53f5936f2e61f","tab":"ask","content":"<div class=\"markdown-text\"><p>目前环境\n&quot;egg&quot;: “^1.9.0”,\n“egg-sequelize”: “^3.1.0”,\n下面这段sequelize查询代码\n<img src=\"//dn-cnode.qbox.me/FjR24EiRTegqJyk9-pVrIgoNbkJT\" alt=\"WechatIMG198.jpeg\">\n当返回结果数据量大的时候，报错heap out of memory，\n当用上述代码生成的sql直接用model.query查询时没问题，\n求教问题根源</p>\n</div>","title":"求教sequelize相关问题","last_reply_at":"2017-11-14T08:01:13.245Z","good":false,"top":false,"reply_count":6,"visit_count":429,"create_at":"2017-11-10T03:26:44.292Z","author":{"loginname":"MUHM","avatar_url":"https://avatars0.githubusercontent.com/u/14190805?v=3&s=120"}},{"id":"5a04f6c888c853c52fd56808","author_id":"56ff5d8e8265278d59c7e46f","tab":"share","content":"<div class=\"markdown-text\"><p>nodejs服务间如何通信，还是走http么，貌似没有有关tcp方面的框架，我想用node做一个中间层下游node没有及时处理请求时，单线程阻塞时，做些异常处理并响应相关静态资源</p>\n</div>","title":"nodejs服务间如何通信","last_reply_at":"2017-11-14T06:07:10.181Z","good":false,"top":false,"reply_count":13,"visit_count":717,"create_at":"2017-11-10T00:46:00.716Z","author":{"loginname":"yudawei1230","avatar_url":"https://avatars.githubusercontent.com/u/15976653?v=3&s=120"}},{"id":"59f92366323d3667540dae25","author_id":"528a32b1d2b3893f2a6aceeb","tab":"share","content":"<div class=\"markdown-text\"><p>好快啊~~~</p>\n<p>—add by alsotang—\n<a href=\"https://nodejs.org/en/\">https://nodejs.org/en/</a>\n<img src=\"//dn-cnode.qbox.me/FoR-dtHGYPo4pK8MHXN4K1_FzgqO\" alt=\"image.png\"></p>\n</div>","title":"Node.js 9.0了！","last_reply_at":"2017-11-14T05:59:13.907Z","good":true,"top":false,"reply_count":15,"visit_count":2558,"create_at":"2017-11-01T01:29:10.699Z","author":{"loginname":"Hanggi","avatar_url":"https://avatars2.githubusercontent.com/u/5997900?v=4&s=120"}},{"id":"583bf2dcc71e606e36aed23d","author_id":"5742636f232f66c870ff7337","tab":"ask","content":"<div class=\"markdown-text\"><p>有人用过pug-loader在webpack中吗？</p>\n<p>我的配置如下</p>\n<p>使用 <code>pug-html-loader</code></p>\n<p>然后配置 webpack.config.js</p>\n<pre class=\"prettyprint\"><code>{\n  test:&#x2F;\\.pug$&#x2F;,\n  exclude: [&#x27;&#x2F;node_modules&#x2F;&#x27;],\n  loader: &#x27;pug-html-loader&#x27;,\n  query: {\n    data: {name:&#x27;test&#x27;},\n    pretty: true\n  }\n},\n</code></pre><p>最后在 pug(jade) 文件中调用数据</p>\n<pre class=\"prettyprint\"><code> h3.title= data.name\n</code></pre><p>但data中没有数据传入，NodeJs版本为7.1, pug-html-loader为1.0.9，webpack为1.13,html-webpack-plugin为2.24</p>\n</div>","title":"无法从pug-loader传参数至pug(jade)模板在webpack中，为什么？","last_reply_at":"2017-11-14T05:35:01.962Z","good":false,"top":false,"reply_count":1,"visit_count":1440,"create_at":"2016-11-28T09:03:24.535Z","author":{"loginname":"dxcqcv","avatar_url":"https://avatars3.githubusercontent.com/u/884046?v=4&s=120"}},{"id":"5a0a6906dea908392cfc892f","author_id":"577f266d49e4faa95429c59d","tab":"ask","content":"<div class=\"markdown-text\"><p>执行npm install的时候\n提示 the windows sdk version 8.1 was mpt found\ngyp err! system windows_nt 6.1.7601\n请问用win7的环境能安装成功吗？</p>\n</div>","title":"Ionic2-CNodeClub 在win7环境下安装失败，求解决方法","last_reply_at":"2017-11-14T03:54:46.778Z","good":false,"top":false,"reply_count":0,"visit_count":145,"create_at":"2017-11-14T03:54:46.778Z","author":{"loginname":"luoboqian","avatar_url":"https://avatars2.githubusercontent.com/u/12182617?v=4&s=120"}},{"id":"5a0a662def333d0e2e61a044","author_id":"5a0a655cdea908392cfc892c","tab":"share","content":"<div class=\"markdown-text\"><p>为大家分享一款基于nodejs的一站式web框架。\nasgc-web\n<a href=\"https://www.npmjs.com/package/asgc-web\">https://www.npmjs.com/package/asgc-web</a></p>\n</div>","title":"一款基于nodejs的一站式web框架","last_reply_at":"2017-11-14T03:44:45.318Z","good":false,"top":false,"reply_count":1,"visit_count":266,"create_at":"2017-11-14T03:42:37.603Z","author":{"loginname":"aoshiguchen","avatar_url":"https://avatars0.githubusercontent.com/u/10580997?v=4&s=120"}},{"id":"5a0a5a4f310be7561d4c0460","author_id":"59ddc34920a1a3647d72aaf3","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>IWinter 是一个路由转控制器的 node 库，只解决一个问题：为了让使用者以更优雅的姿势进行路由的编写。支持在 Express 和 Koa 中使用。</p>\n</blockquote>\n<h3><a href=\"https://github.com/yvanwangl/iwinter\">项目地址</a></h3>\n<h3>简介：</h3>\n<p>最近在学习使用 Typescript ，打算把以前写的博客管理后台用 Typescript 进行全面重构，在重构服务端代码时接触到了 Typescript 的装饰器功能。可以用装饰器对路由进行一层包装，然后就可以这样编写路由：</p>\n<pre class=\"prettyprint\"><code>\t\timport {Path, GET, POST, PathParam, BodyParam} from &#x27;iwinter&#x27;;\n\n\t\t@Path(&#x27;&#x2F;api&#x2F;orders&#x27;)\n\t\tclass OrdersController {\n\n    \t\t@GET\n    \t\t@Path(&#x27;&#x2F;:name&#x2F;:id&#x27;, (ctx, next)=&gt; ~~ctx.params.id &gt; 20)\n   \t\t \tgetAllOrders(@PathParam(&#x27;id&#x27;) id: number, @PathParam(&#x27;name&#x27;) name: string){\n        \t\t\treturn [{\n           \t\t\t\tid: id, name, content: &#x27;test&#x27;, author: &#x27;test&#x27;, comments: []\n       \t\t\t\t}];\n    \t\t}\n\n    \t\t@POST\n    \t\t@Path(&#x27;&#x2F;add&#x27;)\n    \t\taddPost(@BodyParam(&#x27;order&#x27;) order: object){\n        \t\treturn order;\n    \t\t}\n\t\t}\n\n\t\texport default OrdersController;\n</code></pre><p>由于工作中会使用 Java 编写控制层代码（Spring MVC 的控制层代码），所以看到这样的代码简直太亲切了。而且相较于以前的路由编写方式更清晰，更方便维护，所以就将原来的的代码进行了改造。我使用之后发现非常好用，我就想让更多的人都可以使用，所以就诞生了 IWinter 这个库。IWinter 就是将各种装饰器或装饰器工厂函数进行封装然后暴露出一些 API 供大家使用。从此就告别这样编写路由了 ;)</p>\n<pre class=\"prettyprint\"><code>\t\t&#x2F;&#x2F;app.js\n\t\t...\n\t\tlet users = require(&#x27;.&#x2F;routes&#x2F;users&#x27;);\n\t\tlet orders = require(&#x27;.&#x2F;routes&#x2F;orders&#x27;);\n\n\t\tapp.use(&#x27;&#x2F;api&#x2F;users&#x27;, users);\n\t\tapp.use(&#x27;&#x2F;api&#x2F;orders&#x27;, orders);\n\t\t...\n\n\t\t&#x2F;&#x2F;routers&#x2F;orders.js\n\t\t...\n\t\trouter.route(&#x27;&#x2F;&#x27;)\n    \t\t.get(function (req, res, next) {\n        \t\tlet {page, timeRange, customerId, orderNumber} = req.query;\n        \t\tlet limit = constants.PAGE_SIZE;\n        \t\tlet skip = (page - 1) * limit;\n        \t\tlet currentUser = global[Symbol.for(&#x27;currentUser&#x27;)];\n\t\t\t\tlet queryCondition = {\n\t\t\t\t\tuserId: currentUser[&#x27;_id&#x27;]\n\t\t\t\t};\n       \t\t\t...\n</code></pre><h3>谁适合使用 IWinter:</h3>\n<p><code>*</code>Nodejs 用户\n<code>*</code> Typescript 用户\n<code>*</code>Express / Koa 用户</p>\n<h3>IWinter 安装 及 使用</h3>\n<pre class=\"prettyprint\"><code>\tnpm install --save iwinter\n</code></pre><pre class=\"prettyprint\"><code>\timport IWinter from &#x27;iwinter&#x27;;\n</code></pre><p>Koa 中如何使用：</p>\n<pre class=\"prettyprint\"><code>\timport * as Router from &#x27;koa-router&#x27;;\n\t...\n\tapp.use(new IWinter({\n   \t\tengine: &#x27;koa&#x27;,\n    \trouter: new Router(),\n    \tdir: path.join(__dirname, &#x27;controller&#x27;)\n\t}).controller());\n\t...\n</code></pre><p>Express 中如何使用：</p>\n<pre class=\"prettyprint\"><code>\timport * as express from &#x27;express&#x27;;\n\tlet app = express();\n\tlet router = express.Router();\n\t...\n\tnew IWinter({\n    \tengine: &#x27;express&#x27;,\n    \trouter: app,\n    \tdir: path.join(__dirname, &#x27;controller&#x27;),\n   \t\tprefix: &#x27;&#x27;\n\t}).controller();\n</code></pre><h3>使用示例</h3>\n<p><a href=\"https://github.com/yvanwangl/iwinter/tree/master/examples/express-example\">Express 示例</a>\n<a href=\"https://github.com/yvanwangl/iwinter/tree/master/examples/koa-example\">Koa 示例</a></p>\n<p>详细配置可以查看 <a href=\"https://github.com/yvanwangl/iwinter/blob/master/README.md\">项目 README</a></p>\n<blockquote>\n<p>喜欢的话，欢迎使用，欢迎 Star :)</p>\n</blockquote>\n<p>参考文献：\n<a href=\"http://www.tasaid.com/blog/20171011233051.html\">从 JavaScript 到 TypeScript 5 - 路由进化</a></p>\n<p>推荐 Typescript 系列文章：\n<a href=\"http://www.tasaid.com/blog/20171011231943.html\">从 JavaScript 到 TypeScript 1 - 什么是 TypeScript</a></p>\n</div>","title":"IWinter 一个路由转控制器的 Nodejs 库","last_reply_at":"2017-11-14T02:51:59.964Z","good":false,"top":false,"reply_count":0,"visit_count":227,"create_at":"2017-11-14T02:51:59.964Z","author":{"loginname":"yvanwangl","avatar_url":"https://avatars2.githubusercontent.com/u/11405052?v=4&s=120"}},{"id":"5a094028a57c17282e12062d","author_id":"5943d411ff5813233faad924","tab":"ask","content":"<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/Fp6JG02z9HZMXm5VcJAFr4WjS5M3\" alt=\"WechatIMG432.jpeg\">\n<img src=\"//dn-cnode.qbox.me/Fi529pDgVWS2FfF34GShhiR-R8VK\" alt=\"1510555628581.jpg\">\n爬的是接口，因为接口的数据会时不时的更新，所以我设置的是十几秒抓一次。\n测试了一段时间后，我发现接口更新的数据，并没有抓回来。\n想问问大家的想法。</p>\n</div>","title":"关于爬虫的一个小问题","last_reply_at":"2017-11-14T02:37:29.541Z","good":false,"top":false,"reply_count":4,"visit_count":301,"create_at":"2017-11-13T06:48:08.877Z","author":{"loginname":"Kevinzhang29","avatar_url":"https://avatars3.githubusercontent.com/u/29355109?v=4&s=120"}},{"id":"5a08444763329eb474b0c2ce","author_id":"56ac4d7f26d02fc6626bb3b1","tab":"ask","content":"<div class=\"markdown-text\"><p>最近打算研究下源码，想问下源码怎么调试呢？</p>\n</div>","title":"nodejs源码怎么调试？","last_reply_at":"2017-11-14T01:36:48.408Z","good":false,"top":false,"reply_count":2,"visit_count":345,"create_at":"2017-11-12T12:53:27.584Z","author":{"loginname":"oyosc","avatar_url":"https://avatars1.githubusercontent.com/u/13896491?v=4&s=120"}},{"id":"59a3edecd97b7e2308242808","author_id":"59a2dddfd97b7e2308242799","tab":"share","content":"<div class=\"markdown-text\"><p>Github: <a href=\"https://github.com/brookshi/Hitchhiker/\">https://github.com/brookshi/Hitchhiker/</a>   觉得不错的话麻烦 <strong>Star</strong> 支持下，谢谢。</p>\n<p>在线体验： <a href=\"http://www.hitchhiker-api.com/\">http://www.hitchhiker-api.com/</a>    可以用 <code>try without login</code> 来免登录使用。（在线演示不支持压力测试及上传js，虚拟机单核的，撑不住）。</p>\n<h1>v0.4</h1>\n<h3>Pre Request Script</h3>\n<p>这个算是之前就想实现的，拖了会，不过也是有朋友在github里的issue里提出，正好促使我完成这个功能。\n在Pre Request Script里写的脚本会在请求发送前执行，这就使得可以在请求发送前处理一些事情，比如生成一个md5给请求使用，或者读取文件内容，再或者在请求前先请求一个数据，把这个数据做为变量给现在的请求使用，可以做的事有很多，发挥的余地很大。</p>\n<p>现在在脚本里可以使用的方法有：</p>\n<pre class=\"prettyprint language- javascript\"><code>require             &#x2F;&#x2F; 这个做js的都懂，有了这个就有无限可能，内置了&#x27;lodash&#x27;, &#x27;request&#x27;, &#x27;cypro-js&#x27;等库，重要的是支持上传js库\nreadFile            &#x2F;&#x2F; 读取文件\nreadFileByReader    &#x2F;&#x2F; 使用自定义的方法读取文件，比如读取excel\nsaveFile            &#x2F;&#x2F; 保存文件\nremoveFile          &#x2F;&#x2F; 删除文件\nsetEnvVariable      &#x2F;&#x2F; 设置环境变量\ngetEnvVariable      &#x2F;&#x2F; 获取环境变量\nremoveEnvVariable   &#x2F;&#x2F; 删除环境变量\nenvironment         &#x2F;&#x2F; 获取当前环境的名字\n</code></pre><p>当然上面的函数同样可以在Test中使用，下面这些只在Test里支持：</p>\n<pre class=\"prettyprint language- javascript\"><code>responseBody\nresponseObj\nresponseHeaders\nresponseTime\nresponseCode.code\nresponseCode.name \n</code></pre><p><img src=\"https://raw.githubusercontent.com/brookshi/images/master/Hitchhiker/pre_request_script.PNG\" alt></p>\n<h3>项目文件夹</h3>\n<p>对每个项目来说都有一个<code>data</code>文件夹和一个<code>lib</code>文件夹。\n<code>data</code>文件夹用于上传一些测试所需要的数据，可以是任何格式，只要你能读取。\n<code>lib</code>文件夹则用于上传一些js库，需要先压缩成zip格式，上传后会自动解压。\n然后在脚本里就可以通过 <code>readFile</code> 读取 <code>data</code>文件夹下的文件，或者通过 <code>saveFile</code>保存文件到这个文件夹。\n同样可以在脚本通过<code>require</code>来引用上传的js库，然后使用它。</p>\n<p>除了项目文件夹外其实还有一个全局的文件夹，这个文件夹可以放一些全局的js库或数据，比如已经内置了一些常用的js库：<code>uuid</code>，<code>lodash</code>等。</p>\n<h3>schedule支持以小时或分钟为单位</h3>\n<p>这个算是呼声比较高的，之前只是做到按天来跑schedule，后来收到不少这方面的需求，所以增加了以小时或分钟为单位的schedule。</p>\n<h3>支持自定义邮件发送接口</h3>\n<p>这个也算是刚需了，因为很多公司会过滤一些来源不明的邮件，所以 Hitchhiker发出的邮件很可能会收不到，现在增加了一个自定义的邮件接口，Hitchhiker会把数据post到这个接口上，就可以使用公司的邮箱来接发邮箱了。</p>\n<h3>开放schedule的run now接口以便其他程序调用</h3>\n<p>有朋友表示想在Jenkins里调用Schedule的Run接口，这是个好方法，所以开放了这个接口出来，方便其他程序调用。</p>\n<h3>Bug fix</h3>\n<ul>\n<li>schedule的顺序执行无效</li>\n<li>sync有时会覆盖用户已经更改的数据</li>\n<li>sync时环境变量编辑对应框里的内容会被清掉</li>\n</ul>\n<hr>\n<h1>v0.3</h1>\n<h3>这次发布主要增加一个增强协作的功能 - 自动同步更新：</h3>\n<p>我们写code时通常会用git或svn等工具来协同工作，但是Api case也用这种方式的话就显得有点麻烦了，一个接口的属性毕竟就那个几个，没必要修改前fetch &amp; rebase，修改后还要push，Api的协作应该更简单，相信很多人用过Atlassian的wiki，我们在编辑文档的时候常常会收到提醒：某某更改了此文档，是否合并 之类，API的协作也应该这样，简单方便，所以就有这次的更新：</p>\n<p>默认每30s会同步一次，有三种表现：</p>\n<ol>\n<li>本地没有修改的API，这时数据会自动更新。</li>\n<li>本地编辑过的，也就是tab上显示上红点的，这时如果别人更改了API，数据同步后tab里仍会保持编辑的数据，但是会提示些API有人更改过，可以view changes来看是被谁改了些什么，然后决定是否覆盖或放弃本地内容。</li>\n<li>远程上面被删除的，同步会提示此API已经被删除掉了，也就是说再在上面更改已经没有意义，可以关掉此API了。</li>\n</ol>\n<p>下面的图片展示了同步过程：</p>\n<ol>\n<li>首先有两个人在同时维护，左边一个(chrome)，右边一个(firefox)，可以看到左边建立了一个Collection和一个request，右边马上得到了更新。</li>\n<li>然后左边更改了url，在后面加上?a=A，同时右边也做了更改，在url后面加上了?b=B并保存，这时左边得到了case被改的提示，view changes看了更改的内容，选择了覆盖，所以右边的也同步成?a=A了。</li>\n<li>左边把case删掉，右边得到case被删的提示。</li>\n</ol>\n<p>图中的时间间隔设为了5秒，所以会比较快\n<img src=\"https://raw.githubusercontent.com/brookshi/images/master/Hitchhiker/sync.gif\" alt></p>\n<h3>其他改动</h3>\n<ol>\n<li>Url Query支持中文</li>\n</ol>\n<h3>后续计划</h3>\n<p>下个版本的目标是 pre request script以及项目folder，实现初始变量数据源以及在脚本中保存或打开文件的功能，可以借此来实现<a href=\"https://github.com/brookshi/Hitchhiker/issues/29\">动态参数输入源</a></p>\n<h1>v0.2</h1>\n<h2>这次发布的算是一个大版本，主要增加一个重磅功能 - 压力测试：</h2>\n<p>双11快到了，经常会有整点秒杀的活动，秒杀就是一个典型的压力场景，所以建了一个简单的Case来表现这种场景，来展示Hitchhiker压力测试功能：\n<img src=\"https://raw.githubusercontent.com/brookshi/images/master/Hitchhiker/stresstest.gif\" alt></p>\n<p>Hitchhiker使用一个基于Golang的分布式压力节点，这是一个单独的项目：<a href=\"https://github.com/brookshi/Hitchhiker-Node\">Hitchhiker-Node</a>。得益于Golang的交叉编译，轻松跨平台生成文件，所以只有一个可执行文件和一个配置文件，没有环境依赖，直接执行。</p>\n<p>使用时在<a href=\"https://github.com/brookshi/Hitchhiker-Node/releases/tag/v0.1\">release页面</a>先选择对应平台的zip文件下载下来，解压后会有两个文件，一个可执行文件和一个配置文件config.json，打开配置文件，把<code>Address</code>的值从localhost改为部署Hitchhiker机器的ip，然后再执行Hitchhiker-Node文件，这样就弄好了一个压力点。</p>\n<p>如果想压出很大的请求就可以考虑部署到多台机器上，Hitchhiker会自动根据机器的CPU核数来分配任务，当然，一般情况下直接部署到Hitchhiker同一台机器就够用了。</p>\n<p><img src=\"https://raw.githubusercontent.com/brookshi/images/master/Hitchhiker/stress_config.PNG\" alt>\n压力测试用的也是<code>Collection</code>的<code>Request</code>，可以选择性的挑出合适的<code>Request</code>用来做Case，压力测试的参数有：</p>\n<blockquote>\n<ul>\n<li>Repeat: 运行整套请求的次数</li>\n<li>Concurrency: 并发个数</li>\n<li>QPS: 1秒内限制单个节点请求的个数，默认为0，即没有限制</li>\n<li>Timeout: 请求的超时时间设置，单位为秒，默认为0，即没有超时设置</li>\n<li>Keeplive: 设置请求是否使用Keeplive</li>\n</ul>\n</blockquote>\n<p>运行压力测试任务时会实时显示运行状态，包括节点的状态（闪烁表示正在工作），当前任务及任务的数量，下方有三个图表，分别表示</p>\n<ol>\n<li>当前的运行进度，包括完成的数量及TPS</li>\n<li>各个<code>Request</code>的请求消耗时间，包括 DNS, Connect, Request, Min, Max 这五个</li>\n<li>请求失败的状态，包括 No Response, Server Error(500), Test失败 这三种情况</li>\n</ol>\n<h2>其他改动</h2>\n<ol>\n<li>\n<p>源码部署时支持改端口，之前固定用的8080，要改需要改js文件，现在只需在部署文件时改就好了。</p>\n</li>\n<li>\n<p>改正Schedule空跑时的异常。</p>\n</li>\n</ol>\n<h2>后续计划</h2>\n<p>压力测试在国庆后总算做出来，后来又花了一些时间来测试，0.2这个版本算是告一段落。\n接下来版本计划要改下，涉及新功能的都是大版本，bug是小版本。\n下个模块功能是支持API文档，希望能是一个自定义的，所见即所得，支持导出常用格式的API文档系统。\n小功能和bug会持续改进。</p>\n<h1>v0.1.3</h1>\n<h3>这次版本主要增加一个重磅功能 - 参数化请求：</h3>\n<h3>参数化请求</h3>\n<p>什么是参数化请求，就是把一个Api里可变的点提取出来，参数化，这样就可以用一个Case覆盖到所有可变请求。</p>\n<p>参考下图（比较大，可能会比较慢出来）：<code>parameters</code>就是用来构建参数化请求的，请求通常有很多参数，比如query string, body里的变化点等，这些参数可能会有不止一个值，每个都要覆盖的话需要写很多request。</p>\n<p>举个例子：比如一个request有三个可变的参数<code>A</code>, <code>B</code>, <code>C</code>，每个参数又分别有3个值，A的<code>1，2，3</code>， B的<code>4，5，6</code>， C的<code>7，8，9</code>，这样随机组合下来会有<code>3*3*3=27</code>个request：</p>\n<pre class=\"prettyprint\"><code>147 148 148 157 158 159 167 168 169\n247 248 248 257 258 259 267 268 269\n347 348 348 357 358 359 367 368 369\n</code></pre><p>很麻烦有没有，如果再多两个参数呢，轻松过百了呀，想想都头大，但其实它们之间只是一点不同，何必要费这么大劲呢，参数化请求可以帮你做这个事，只需要把可变的参数写在parameter里面，Hitchhiker会自动构建出所有request。</p>\n<p><code>parameters</code>有两种组合方式，一种是所有组合<code>Many to Many</code>，另一种是一对一组合<code>One to One</code>，上面生个27个request的就是<code>ManytoMany</code>，如果用一对一组合的话就只有3个，分别是：<code>147, 258, 369</code>。</p>\n<p><code>Parameters</code>的格式是一个json对象，对象的下一层是变量以及它的值：数组。看个例子：</p>\n<pre class=\"prettyprint language- json\"><code>{\n    &quot;A&quot;: [1, 2, 3],\n    &quot;B&quot;: [3, 4, 5], \n    &quot;C&quot;: [7, 8, 9]\n}\n</code></pre><p>使用的方式同变量一样，用<code>{{}}</code>包起来。</p>\n<p>下图就展示了参数化请求的使用方式，可变的三个参数<code>name</code>， <code>pwd</code>， <code>age</code>。\n<code>name</code>有两个值：<code>tom</code>和<code>jerry</code>， <code>pwd</code>有两个值：<code>123</code>和<code>456</code>，<code>age</code>也是两个值：<code>20</code>和<code>18</code>，使用<code>OnetoOne</code>时会生成两个请求：<code>name:tom, pwd:123, age:20</code>和<code>name:jerry, pwd:456, age:18</code>，一一对应的，可以分别请求，也可以一起请求。\n如果选了<code>ManytoMany</code>就会有8个请求，这里就不一一列举出来。\n参数化请求的request保存后左边对应的item里会显示出请求的真正个数，如图中的<code>8</code>。\n参数化请求跑schedule一样没问题，会自动拆分开跑和显示。</p>\n<p>大图：右键新标签打开图片\n<img src=\"https://raw.githubusercontent.com/brookshi/images/master/Hitchhiker/parameters.gif\" alt></p>\n<h3>处理对比数据</h3>\n<p>Hitchhiker的一个重要功能就是可以对比不同环境的返回数据，之前是直接对比response，但实际上往往想要对比的是其中一部分或去掉可变部分，考虑一种情况，返回的response里带有一个当前时间，也就表示每次返回的数据都是不同的，因为时间肯定不一样，这样就影响了对比结果，但是这个时间没什么对比意义，所以我们需要在对比前把它去掉，这时可以用这个功能了。</p>\n<p>具体用法：在<code>test</code>里用js处理<code>responseObj</code>，然后用<code>$export$(data)</code>函数导出处理后的数据（data就是处理后的数据），然后跑<code>schedule</code>时就会用导出的数据进行对比了。</p>\n<h3>默认Headers</h3>\n<p>之前有加一个header收藏功能，方便使用一些常用的header，但是有些server会校验一些请求头，比如<code>Accept</code>,<code>UserAgent</code>等，这个是每个请求都需要带的，每个request都写也有些麻烦，现在可以配置一些默认header，这些header可以在根目录下的appconfig.json里配置，默认定义的是这些：</p>\n<pre class=\"prettyprint language- json\"><code>&quot;defaultHeaders&quot;: [\n    &quot;Accept:*&#x2F;*&quot;,\n    &quot;User-Agent:Mozilla&#x2F;5.0 (Windows NT 6.1; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;60.0.3112.113 Safari&#x2F;537.36&quot;,\n    &quot;Cache-Control:no-cache&quot;\n]\n</code></pre><p>可以根据需要自行修改。</p>\n<h3>后续计划</h3>\n<p>本来的计划是两周一版本，其中一周做小版本的新功能和改bug，另一周做大版本的压力测试。不过这次参数化请求比预想的要麻烦些，上面两周时间基本都花这上面了，压力测试这块就没进展，下两周除了改bug外就全力做压力测试这块，希望国庆过后能做到差不多。</p>\n<p>Github: <strong><a href=\"https://github.com/brookshi/Hitchhiker\">https://github.com/brookshi/Hitchhiker</a></strong>， 觉得不错的话麻烦 <strong>Star</strong> 支持下，谢谢。</p>\n<h1>v0.1.2</h1>\n<h3>这次版本主要是增加一些体验方面的更新：</h3>\n<h3>request的header提示及自动完成</h3>\n<p>request的header种类基本就那些，但纯靠手写有时会写错，导致请求不到数据，很麻烦。于是把常用header加到自动提示里面，方便使用。</p>\n<h3>header的收藏功能</h3>\n<p>一个项目的request的header其实用来用去都是那几个，每个request都去写这些重复的即使有提示也显得麻烦，这时可以添加到收藏，下次再用直接选进来就可以了。（可以右键选新标签中打开图片，看起来清楚些）</p>\n<p><img src=\"https://github.com/brookshi/Hitchhiker/blob/master/doc/images/header.gif?raw=true\" alt></p>\n<h3>tests的全局函数</h3>\n<p>很多request的tests里会用到同样功能的函数，每个都写的话麻烦不说，维护起来也不方便，考虑像写代码一样，应该提取共同部分，所以增加了一个全局脚本，可以在Project里定义，其下的Request可以直接使用。</p>\n<p><img src=\"http://images2017.cnblogs.com/blog/884430/201709/884430-20170910222414476-2027808564.png\" alt></p>\n<h3>清除本地Cache功能</h3>\n<p>Hitchhiker会把用户所有的更改都记在浏览器的indexDB中，但有时会有一些情况比如说想放弃所有更改，可以清除本地cache，所有数据全部用最新的数据库里的。</p>\n<h3>UI调整</h3>\n<p>主要是字体改了，之前统一用的adobe开源的一款SourceCodePro字体，因为是等宽字体，有朋友反应说看起来不舒服，想想有道理，所以把除了代码之外的都使用系统字体，看起来紧凑点。</p>\n<h3>后续计划</h3>\n<p>0.2大版本的分布式压力测试还是开发中，测试tool用go写的，代码基本差不多，接下来主要是通信方面。</p>\n<p>0.1.3小版本的主要还是小功能和体验上的改进，计划引入一个比较有用的新功能：参数化请求，因为很多需要测试的api大体上差不多，只是query或者body里变了一点，如果重复添加request的话显得麻烦且维护不便，参数化可以把这些变化封装到参数里，一个request就可以了，系统根据参数自动生成多个请求。</p>\n<hr>\n<h1>v0.1.1</h1>\n<p>Hitchhiker 是一款开源的 Restful Api 集成测试工具，你可以在轻松部署到本地，和你的team成员一起协作管理Api。</p>\n<p>先上图看看：</p>\n<p><img src=\"https://github.com/brookshi/Hitchhiker/raw/master/doc/images/collection.png\" alt=\"https://github.com/brookshi/Hitchhiker/raw/master/doc/images/collection.png\"></p>\n<p><img src=\"https://github.com/brookshi/Hitchhiker/raw/master/doc/images/history.png\" alt=\"https://github.com/brookshi/Hitchhiker/raw/master/doc/images/history.png\"></p>\n<p><img src=\"https://github.com/brookshi/Hitchhiker/raw/master/doc/images/env.png\" alt=\"https://github.com/brookshi/Hitchhiker/raw/master/doc/images/env.png\"></p>\n<p><img src=\"https://github.com/brookshi/Hitchhiker/raw/master/doc/images/schedule.png\" alt=\"https://github.com/brookshi/Hitchhiker/raw/master/doc/images/schedule.png\"></p>\n<h3>能做什么</h3>\n<ul>\n<li>\n<p>Team协作开发Api</p>\n</li>\n<li>\n<p>Api历史修改记录及支持diff展示</p>\n</li>\n<li>\n<p>支持多环境变量及运行时变量</p>\n</li>\n<li>\n<p>支持Schedule及批量run</p>\n</li>\n<li>\n<p>不同环境下的请求数据对比 (eg: stage vs product)</p>\n</li>\n<li>\n<p>易部署 (支持 docker, windows, linux), 数据都存在自己这里，不会上传及丢失</p>\n</li>\n<li>\n<p>会记往任何修改，不用怕没保存时session失效或系统重启</p>\n</li>\n<li>\n<p>支持导入Postman v1 collections</p>\n</li>\n<li>\n<p>性能测试 (开发中…)</p>\n</li>\n<li>\n<p>Api文档 (计划中…)</p>\n</li>\n</ul>\n<h3>如何部署</h3>\n<p>首推使用 docker 部署，简单快捷，具体操作参考 <a href=\"https://github.com/brookshi/Hitchhiker/blob/master/doc/howtoinstall-docker-cn.md\">deploy with docker</a></p>\n<p>如果没有docker环境也可以使用源码部署，也很简单</p>\n<p>linux 请参考 <a href=\"https://github.com/brookshi/Hitchhiker/blob/master/doc/howtoinstall-linux-cn.md\">deploy to linux</a></p>\n<p>windows 请参考 <a href=\"https://github.com/brookshi/Hitchhiker/blob/master/doc/howtoinstall-win-cn.md\">deploy to win</a></p>\n<h3>如何使用</h3>\n<p>参考 <a href=\"https://github.com/brookshi/Hitchhiker/blob/master/doc/howtouse-cn.md\">使用说明</a></p>\n<h3>用到的技术</h3>\n<p>前后端分离，前端采用 React + Redux + AntDesign，后端基于 Nodejs， 采用 Koajs + TypeORM + MySQL。</p>\n<p>语言统一用的 Typescript。</p>\n<p>测试的话，前端用Jest，覆盖了逻辑最多的 reducer，后端使用的就是本工具来测试自己，这对时间有限的我来说算是最有性价比的选择。</p>\n<h3>开源</h3>\n<p>可以访问 <a href=\"http://www.hitchhiker-api.com/\">http://www.hitchhiker-api.com/</a> 来使用，点击 <code>try without login</code> 免注册登录，另外，为了免备案，服务器在海外的，所以速度上可能会有点慢，抽疯时甚至可能访问不了，请谅解。</p>\n<p>当然最好还是在本地局域网部署，用起来会比较爽。</p>\n<p>Github: <strong><a href=\"https://github.com/brookshi/Hitchhiker\">https://github.com/brookshi/Hitchhiker</a></strong>， 觉得不错的话麻烦 <strong>Star</strong> 支持下，谢谢。</p>\n</div>","title":"开源 基于Nodejs的Api 测试工具 -  更新 v0.4，支持Pre Request Script及require任何上传的脚本","last_reply_at":"2017-11-13T23:33:19.093Z","good":false,"top":false,"reply_count":17,"visit_count":2026,"create_at":"2017-08-28T10:18:20.121Z","author":{"loginname":"brookshi","avatar_url":"https://avatars0.githubusercontent.com/u/13607728?v=4&s=120"}},{"id":"5a0956fcdea908392cfc890b","author_id":"5a095617a57c17282e12063c","tab":"ask","content":"<div class=\"markdown-text\"><p>2017-11-13 16:23:01.601 xcodebuild[24568:190947] [MT] PluginLoading: Required plug-in compatibility UUID DFFB3951-EB0A-4C09-9DAC-5F2D28CC839C for plug-in at path ‘~/Library/Application Support/Developer/Shared/Xcode/Plug-ins/VVDocumenter-Xcode.xcplugin’ not present in DVTPlugInCompatibilityUUIDs\nCC(target) Release/obj.target/ffi/deps/libffi/src/prep_cif.o\nCC(target) Release/obj.target/ffi/deps/libffi/src/types.o\nCC(target) Release/obj.target/ffi/deps/libffi/src/raw_api.o\nCC(target) Release/obj.target/ffi/deps/libffi/src/java_raw_api.o\nCC(target) Release/obj.target/ffi/deps/libffi/src/closures.o\nCC(target) Release/obj.target/ffi/deps/libffi/src/x86/ffi.o\nCC(target) Release/obj.target/ffi/deps/libffi/src/x86/ffi64.o\nCC(target) Release/obj.target/ffi/deps/libffi/src/x86/darwin.o\nCC(target) Release/obj.target/ffi/deps/libffi/src/x86/darwin64.o\nLIBTOOL-STATIC Release/libffi.a\nlibtool: unrecognized option <code>-static' libtool: Try</code>libtool --help’ for more information.\nmake: *** [Release/libffi.a] Error 1</p>\n</div>","title":"node install ffi报错，大神们，求解答","last_reply_at":"2017-11-13T17:51:59.239Z","good":false,"top":false,"reply_count":1,"visit_count":199,"create_at":"2017-11-13T08:25:32.864Z","author":{"loginname":"zhangrss","avatar_url":"https://avatars3.githubusercontent.com/u/4928491?v=4&s=120"}},{"id":"59eeb05af8d374775c0157d0","author_id":"59e4a9e9bcfcc03162f2fed4","tab":"ask","content":"<div class=\"markdown-text\"><p>找大佬指点~~~~~</p>\n</div>","title":"网页当中的分享到QQ，微信，是怎么做的？","last_reply_at":"2017-11-13T14:29:50.450Z","good":false,"top":false,"reply_count":15,"visit_count":1339,"create_at":"2017-10-24T03:15:38.770Z","author":{"loginname":"wwdDongDong","avatar_url":"https://avatars1.githubusercontent.com/u/30905492?v=4&s=120"}},{"id":"5936707cdfbb657c2a05ca6e","author_id":"580b4b3305dbe08f50be320d","tab":"ask","content":"<div class=\"markdown-text\"><p>像下面的****** 用浏览器F12  console面板 直接运行  输出是 ZEJ4N/0L1aFqOg==  如果用node运行 可以？</p>\n<p>[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+({}[[]]+[])[+[]]+({}[[]]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]]<a href>({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]</a>())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()([][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]]<a href>({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]</a>())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()(({}+[])[+[]])[+[]]+(!![]+!![]+!![]+!![]+!![]+[])+(![]+[])[+!![]])+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+({}[[]]+[])[+[]]+({}[[]]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]]<a href>({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]</a>())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()([][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]]<a href>({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]</a>())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()(({}+[])[+[]])[+[]]+(!![]+!![]+!![]+!![]+[])+(!![]+!![]+!![]+!![]+!![]+[]))+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+({}[[]]+[])[+[]]+({}[[]]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]]<a href>({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]</a>())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()([][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]]<a href>({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]</a>())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()(({}+[])[+[]])[+[]]+(!![]+!![]+!![]+!![]+[])+(![]+[])[+!![]])+(!![]+!![]+!![]+!![]+[])+(+{}+[])[+[]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]]<a href>({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]</a>())[!![]+!![]+!![]+!![]+!![]+!![]]+(+[]+[])+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+({}[[]]+[])[+[]]+({}[[]]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]]<a href>({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]</a>())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()([][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]]<a href>({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]</a>())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()(({}+[])[+[]])[+[]]+(!![]+!![]+!![]+!![]+[])+({}[[]]+[])[!![]+!![]])+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]]<a href>({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]</a>())[+[]]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+({}[[]]+[])[+[]]+({}[[]]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]]<a href>({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]</a>())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()([][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]]<a href>({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]</a>())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()(({}+[])[+[]])[+[]]+(!![]+!![]+!![]+!![]+!![]+[])+(!![]+!![]+!![]+!![]+!![]+!![]+!![]+!![]+[]))+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+({}[[]]+[])[+[]]+({}[[]]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]]<a href>({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]</a>())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()([][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]]<a href>({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]</a>())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()(({}+[])[+[]])[+[]]+(!![]+!![]+!![]+!![]+[])+(!![]+!![]+!![]+!![]+[]))+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+({}[[]]+[])[+[]]+({}[[]]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]]<a href>({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]</a>())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()([][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]]<a href>({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]</a>())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()(({}+[])[+[]])[+[]]+(!![]+!![]+!![]+!![]+!![]+[])+(!![]+!![]+!![]+!![]+!![]+!![]+!![]+!![]+[]))+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+({}[[]]+[])[+[]]+({}[[]]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]]<a href>({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]</a>())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()([][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]]<a href>({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]</a>())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()(({}+[])[+[]])[+[]]+(!![]+!![]+!![]+!![]+!![]+[])+(!![]+!![]+!![]+!![]+!![]+!![]+!![]+[]))+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+({}[[]]+[])[+[]]+({}[[]]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]]<a href>({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]</a>())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()([][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]]<a href>({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]</a>())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()(({}+[])[+[]])[+[]]+(!![]+!![]+!![]+!![]+!![]+!![]+!![]+[])+(!![]+!![]+!![]+!![]+!![]+!![]+!![]+[]))+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+({}[[]]+[])[+[]]+({}[[]]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]]<a href>({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]</a>())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()([][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]]<a href>({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]</a>())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()(({}+[])[+[]])[+[]]+(!![]+!![]+!![]+[])+({}[[]]+[])[!![]+!![]])+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+({}[[]]+[])[+[]]+({}[[]]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]]<a href>({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]</a>())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()([][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]]<a href>({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]</a>())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()(({}+[])[+[]])[+[]]+(!![]+!![]+!![]+[])+({}[[]]+[])[!![]+!![]])!![]+[])[!![]+!![]+!![]])()(({}+[])[+[]])[+[]]+(!![]+!![]+!![]+[])+({}[[]]+[])[!![]+!![]])</p>\n</div>","title":"像这种特殊的JS代码 Node 这么运行？","last_reply_at":"2017-11-13T14:21:56.115Z","good":false,"top":false,"reply_count":38,"visit_count":1694,"create_at":"2017-06-06T09:06:04.984Z","author":{"loginname":"eoo520","avatar_url":"https://avatars0.githubusercontent.com/u/7720780?v=4&s=120"}},{"id":"5a03d21b84ed7ceb219ea83d","author_id":"5a03d028ad77fa200454916a","tab":"share","content":"<div class=\"markdown-text\"><p>链接：<a href=\"https://chun-chat.herokuapp.com\">https://chun-chat.herokuapp.com</a></p>\n<ul>\n<li>使用MEVN技术栈 + socket.io开发。使用Vuex管理组件状态。</li>\n<li>前后端分离，后端（Nodejs）提供API, 对应操作数据库资源. 前端（Vuejs）发送API请求, 更新视图.</li>\n<li>注册表实现后端验证, 用户输入时检查邮箱和用户名是否被注册, 注册表使用reCAPTCHA提供验证功能. 前端使用vee-validate检查用户输入, 后端使用express-validator检查POST body. 使用passport定义登录策略. 使用bcrypt加密, 比较用户密码.</li>\n<li>使用JWT实现用户登录。用户登录成功后将用户基本信息编码得到JWT，使用cookie存放JWT。</li>\n<li>允许用户注册, 登录, 登出, 上传图片修改头像, 发布个性签名, 添加表情. 允许用户搜索好友, 添加好友, 实时接收好友请求. 提供消息提示, 好友请求提示, 对方正在输入提示. 根据朋友性别更改聊天气泡颜色. 按需加载历史聊天记录, 允许用户删除聊天. 记录在线用户, 防止账号同时登陆. 定时更新好友信息.</li>\n</ul>\n<p>** 头像图床用的imgur, 大陆的ip不能上传图片。。。</p>\n<p>新手轻喷~~~</p>\n<p>我的用户名是junlinguo11，欢迎加我嘻嘻</p>\n</div>","title":"新手用MEVN写了一个在线聊天app~~","last_reply_at":"2017-11-13T14:21:30.315Z","good":false,"top":false,"reply_count":7,"visit_count":567,"create_at":"2017-11-09T03:57:15.376Z","author":{"loginname":"junlinguo11","avatar_url":"https://avatars1.githubusercontent.com/u/20136619?v=4&s=120"}}]}